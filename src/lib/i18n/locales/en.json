{
	"common": {
		"qaToolbox": "QA Toolbox",
		"madeBy": "Made by Anton",
		"donate": "Donate",
		"privacy": "Privacy Policy",
		"about": "About",
		"privacyFirst": "Runs locally in your browser. No tracking. No accounts.",
		"noTracking": "No tracking",
		"localOnly": "Local-only",
		"builtBy": "Part of",
		"moreToolsComing": "More tools coming soon...",
		"copy": "Copy",
		"clear": "Clear",
		"parse": "Parse"
	},
	"nav": {
		"testDataGenerator": "Test Data",
		"apiResponseValidator": "API Validator",
		"statusCodeReference": "Status Codes",
		"userAgentParser": "User Agent",
		"headersInspector": "Headers"
	},
	"home": {
		"title": "QA Toolbox",
		"description": "Fast, privacy-first tools for QA testing. No backend. No tracking. Everything runs locally in your browser.",
		"testDataGenerator": {
			"title": "Test Data Generator",
			"description": "Generate test data: emails, phone numbers, UUIDs, names, addresses, and more.",
			"tags": ["Email", "Phone", "UUID"]
		},
		"apiResponseValidator": {
			"title": "API Response Validator",
			"description": "Validate JSON responses against schemas. Check structure, types, and required fields.",
			"tags": ["JSON Schema", "Validation", "API"]
		},
		"statusCodeReference": {
			"title": "Status Code Reference",
			"description": "Quick reference for HTTP status codes with descriptions and use cases.",
			"tags": ["HTTP", "Status", "Reference"]
		},
		"userAgentParser": {
			"title": "User Agent Parser",
			"description": "Parse User-Agent strings to extract browser, OS, device, and version information.",
			"tags": ["Browser", "OS", "Device"]
		},
		"headersInspector": {
			"title": "Headers Inspector",
			"description": "Parse and analyze HTTP headers. Understand their purpose and detect configuration issues.",
			"tags": ["HTTP", "Headers", "CORS"]
		}
	},
	"testDataGenerator": {
		"title": "Test Data Generator - QA Toolbox",
		"description": "Generate test data locally: emails, phone numbers, UUIDs, names, addresses, and more. No data sent to servers.",
		"heading": "Test Data Generator",
		"subtitle": "Test Data Generator is a local tool for generating test data without a backend. Define a data schema, preview generated records, and export them to JSON or CSV for testing, APIs, and development.",
		"whatIsTestData": "What is Test Data Generation?",
		"testDataDescription": "Test data generation is the process of creating realistic, structured data for testing purposes. This tool allows you to define a schema with different field types (strings, numbers, dates, emails, etc.) and generate multiple rows of data that match your requirements.",
		"parameters": "Parameters",
		"presets": "Presets",
		"presetsDescription": "Predefined schemas for quick start:",
		"presetsList": "User, Order, Address, Event",
		"fields": "Fields",
		"fieldName": "Field name — key name in the output",
		"fieldType": "Type — data type (uuid, email, name, phone, address, date, string)",
		"fieldRequired": "Required — ensures the field is always present",
		"fieldManage": "Reorder / Duplicate / Remove — manage field structure",
		"preview": "Preview",
		"previewDescription": "Displays generated data in table form",
		"previewRegenerate": "Regenerate creates a new dataset with the same schema",
		"export": "Export",
		"exportRows": "Rows — number of records to generate",
		"exportSeed": "Seed — fixed value for reproducible results",
		"exportFormat": "Format — JSON or CSV",
		"exportArrayKey": "Array key (optional) — wraps output array in an object",
		"exportActions": "Copy / Download — copy data or download file",
		"features": "Features",
		"featureSchema": "Define custom schemas with multiple field types",
		"featureSeed": "Use seeds for reproducible, deterministic data",
		"featureExport": "Export to JSON or CSV formats",
		"featureLocal": "All processing happens locally in your browser",
		"useCases": "Use Cases",
		"useCase1": "Creating test datasets for API testing",
		"useCase2": "Generating sample data for database seeding",
		"useCase3": "Building mock data for frontend development",
		"useCase4": "Creating test fixtures for automated testing",
		"privacy": "Privacy",
		"privacyText": "All data is generated locally in your browser. No data is sent to any server.",
		"confirmReplaceTitle": "Replace Schema?",
		"confirmReplaceMessage": "This will replace your current schema. Continue?",
		"confirmCancel": "Cancel",
		"confirmContinue": "Continue"
	},
	"payloadBuilder": {
		"title": "Payload Builder - QA Toolbox",
		"description": "Build and break JSON payloads for API testing. Create invalid variants to test validation.",
		"heading": "Payload Builder + Breaker",
		"subtitle": "Build JSON payloads visually or in code. Generate invalid variants to test API validation.",
		"whatIsPayloadBuilder": "What is Payload Builder + Breaker?",
		"payloadBuilderDescription": "Payload Builder + Breaker is a local tool for creating and intentionally breaking JSON payloads for API testing. Build valid payloads visually or in JSON, then generate invalid variants to test API validation and error handling. All processing happens locally in your browser.",
		"parameters": "Parameters",
		"templates": "Templates",
		"templatesDescription": "Predefined payloads for common API requests",
		"templatesList": "",
		"jsonEditor": "JSON Editor",
		"jsonEditorDescription": "Edit, format, and minify raw JSON with validation",
		"treeBuilder": "Tree Builder",
		"treeBuilderDescription": "Visual JSON editor to add, remove, and change fields",
		"breaker": "Variants (Breaker)",
		"breakerDescription": "Generate invalid payloads (missing fields, wrong types, nulls, edge cases)",
		"breakerPresets": "",
		"breakerPresetsList": "",
		"output": "Output",
		"outputDescription": "Preview, compare, copy, or export payloads",
		"privacy": "Privacy",
		"privacyText": "All data is processed locally in your browser. No data is sent to any server."
	},
	"apiResponseValidator": {
		"title": "API Response Validator - QA Toolbox",
		"description": "API Validator is a developer and QA tool for verifying that JSON payloads match an expected contract defined by JSON Schema. It highlights validation errors, schema issues, and formatting problems to help ensure your API requests and responses are correct before hitting the backend. All checks are performed locally in your browser for faster feedback and better privacy.",
		"heading": "API Validator",
		"subtitle": "API Validator helps you validate JSON request payloads against JSON Schema directly in your browser.Quickly detect schema mismatches, invalid types, and missing required fields during API development and QA testing",
		"payloadLabel": "Payload JSON",
		"outputLabel":"Output",
		"schemaLabel": "Schema JSON",
		"validate": "Validate",
		"autoValidate": "Auto-validate",
		"formatPayload": "Format Payload",
		"formatSchema": "Format Schema",
		"selectPreset": "Sample Schema",
		"reset": "Reset",
		"valid": "Valid",
		"invalid": "Invalid",
		"parseError": "Parse Error",
		"schemaParseError": "Schema Parse Error",
		"line": "Line",
		"column": "Column",
		"error": "error",
		"errors": "errors",
		"keyword": "Keyword",
		"expected": "Expected",
		"received": "Received",
		"copy": "Copy",
		"copied": "Copied!",
		"copyError": "Copy error",
		"noValidation": "Click Validate to check your JSON against the schema",
		"formattedOutput": "Formatted Output",
		"whatIs": "What is API Validator?",
		"parameters": "Parameters",
		"payloadDesc": "JSON payload to validate",
		"schemaDesc": "JSON Schema (draft 2020-12 or draft-07)",
		"autoValidateDesc": "Automatically validate on input changes",
		"presets": "Presets",
		"presetsDesc": "Predefined schemas and payloads for common API requests",
		"format": "Format",
		"formatDesc": "Format JSON with proper indentation",
		"privacy": "Privacy",
		"privacyText": "All validation happens locally in your browser. No data is sent to any server.",
		"useCases": "Use Cases",
		"useCasesSubtitle": "Use API Validator to:",
		"useCase1": "Validate API request bodies before sending requests",
		"useCase2": "Test backend validation rules during QA",
		"useCase3": "Debug schema mismatches and invalid payloads",
		"useCase4": "Verify required fields, data types, and formats",
		"whyUse": "Why use this tool?",
		"whyUse1": "Instant feedback for API payload validation",
		"whyUse2": "Supports JSON Schema (draft-07, draft-2020-12)",
		"whyUse3": "Ideal for developers and QA engineers",
		"typicalWorkflow": "Typical Workflow",
		"workflow1": "Paste or write your JSON payload",
		"workflow2": "Define or select a JSON Schema",
		"workflow3": "Click Validate or enable auto-validation",
		"workflow4": "Review validation errors or confirm payload is valid",
		"workflow5": "Copy the formatted output if needed"
	},
	"statusCodeReference": {
		"title": "HTTP Status Codes Explorer - QA Toolbox",
		"description": "Fast, local reference for HTTP status codes with descriptions, use cases, and API response templates.",
		"heading": "HTTP Status Codes Explorer",
		"subtitle": "Quick reference for HTTP status codes with descriptions, use cases, and suggested API responses.",
		"searchPlaceholder": "Search by code or keyword...",
		"categoryAll": "All",
		"category1xx": "1xx",
		"category2xx": "2xx",
		"category3xx": "3xx",
		"category4xx": "4xx",
		"category5xx": "5xx",
		"commonOnly": "Common only",
		"categoryLabel": {
			"informational": "Informational",
			"success": "Success",
			"redirection": "Redirection",
			"clientError": "Client Error",
			"serverError": "Server Error"
		},
		"whenToUse": "When to use",
		"commonCauses": "Common causes",
		"whatToReturn": "What to return",
		"testingChecklist": "Testing checklist",
		"relatedCodes": "Related codes",
		"copyJson": "Copy JSON",
		"copyTitle": "Copy title",
		"copied": "Copied!",
		"noResults": "No results found",
		"noResultsSuggestion": "Try searching for: 404, not found, rate limit, unauthorized",
		"whatIs": "What is HTTP Status Codes Explorer?",
		"whatIsDescription": "HTTP Status Codes Explorer is a local tool for quickly understanding HTTP status codes, their typical causes, and suggested API responses. It helps QA engineers, developers, and backend engineers make informed decisions about which status codes to use and how to structure error responses.",
		"qaUsage": "How QA uses status codes in API testing",
		"qaUsageDescription": "QA engineers use status codes to verify API behavior, test error handling, and ensure proper response formats. This tool helps identify the correct status code for different scenarios and provides example responses for testing.",
		"commonMistakes": "Common mistakes: 401 vs 403, 409 vs 422, 502 vs 504",
		"commonMistakesDescription": "401 (Unauthorized) means authentication is missing or invalid, while 403 (Forbidden) means the user is authenticated but lacks permission. 409 (Conflict) indicates a state conflict, while 422 (Unprocessable Entity) means the request is well-formed but semantically invalid. 502 (Bad Gateway) is an upstream server error, while 504 (Gateway Timeout) means the upstream server didn't respond in time.",
		"statusCodes": {
			"200": {
				"summary": "Request succeeded. The standard response for successful HTTP requests.",
				"whenToUse1": "Successful GET, PUT, or PATCH requests",
				"whenToUse2": "Returning data in response body",
				"whenToUse3": "Standard success response",
				"causes1": "Normal successful request processing",
				"causes2": "Resource retrieved or updated successfully",
				"checklist1": "Verify response body contains expected data",
				"checklist2": "Check Content-Type header matches response format",
				"checklist3": "Ensure response is properly formatted"
			},
			"201": {
				"summary": "Resource created successfully. Typically used after POST requests that create new resources.",
				"whenToUse1": "After successful POST request creating a new resource",
				"whenToUse2": "When returning the created resource in response body",
				"causes1": "New resource successfully created",
				"causes2": "Resource creation with location header",
				"checklist1": "Verify Location header points to new resource",
				"checklist2": "Check response body contains created resource",
				"checklist3": "Ensure resource ID is included"
			},
			"204": {
				"summary": "Request succeeded but no content to return. Used for successful operations that don't need a response body.",
				"whenToUse1": "Successful DELETE requests",
				"whenToUse2": "Successful PUT/PATCH with no response needed",
				"causes1": "Operation completed successfully without content",
				"checklist1": "Verify response body is empty",
				"checklist2": "Check that operation actually succeeded"
			},
			"400": {
				"summary": "Invalid request syntax or parameters. The server cannot process the request due to client error.",
				"whenToUse1": "Malformed request syntax",
				"whenToUse2": "Invalid request parameters",
				"whenToUse3": "Missing required fields",
				"causes1": "Invalid JSON syntax",
				"causes2": "Missing required parameters",
				"causes3": "Invalid parameter types",
				"causes4": "Malformed request body",
				"checklist1": "Verify error message explains the issue",
				"checklist2": "Check error response includes requestId",
				"checklist3": "Ensure error format is consistent",
				"checklist4": "Test with various invalid inputs"
			},
			"401": {
				"summary": "Authentication required or failed. The client must authenticate to get the requested response.",
				"whenToUse1": "Missing or invalid authentication token",
				"whenToUse2": "Expired authentication credentials",
				"whenToUse3": "Authentication scheme not supported",
				"causes1": "No Authorization header provided",
				"causes2": "Invalid or expired token",
				"causes3": "Authentication credentials are incorrect",
				"checklist1": "Verify WWW-Authenticate header is present",
				"checklist2": "Check error message doesn't leak sensitive info",
				"checklist3": "Test with missing, invalid, and expired tokens",
				"checklist4": "Ensure 401 is used, not 403 for auth issues"
			},
			"403": {
				"summary": "Access denied. The client does not have permission to access the resource.",
				"whenToUse1": "User is authenticated but lacks permission",
				"whenToUse2": "Resource exists but access is forbidden",
				"whenToUse3": "Insufficient privileges for the operation",
				"causes1": "User lacks required permissions",
				"causes2": "Resource access restricted by policy",
				"causes3": "Operation not allowed for user role",
				"checklist1": "Verify user is authenticated (not 401)",
				"checklist2": "Check error message explains permission issue",
				"checklist3": "Test with different user roles"
			},
			"404": {
				"summary": "Resource not found. The server cannot find the requested resource.",
				"whenToUse1": "Resource doesn't exist",
				"whenToUse2": "Invalid resource ID or path",
				"whenToUse3": "Endpoint doesn't exist",
				"causes1": "Resource was deleted",
				"causes2": "Incorrect URL or resource ID",
				"causes3": "Resource never existed",
				"causes4": "Typo in request path",
				"checklist1": "Verify error message is user-friendly",
				"checklist2": "Check response doesn't reveal internal structure",
				"checklist3": "Test with various invalid IDs"
			},
			"409": {
				"summary": "Resource conflict. The request conflicts with the current state of the resource.",
				"whenToUse1": "Duplicate resource creation",
				"whenToUse2": "Concurrent modification conflict",
				"whenToUse3": "State conflict (e.g., deleting active resource)",
				"causes1": "Resource already exists with same identifier",
				"causes2": "Optimistic locking conflict",
				"causes3": "Business rule violation",
				"checklist1": "Verify error explains the conflict",
				"checklist2": "Check if retry logic is needed",
				"checklist3": "Test concurrent modification scenarios"
			},
			"415": {
				"summary": "Unsupported media type. The request entity has a media type which the server does not support.",
				"whenToUse1": "Invalid Content-Type header",
				"whenToUse2": "Server only accepts specific media types",
				"causes1": "Content-Type not supported (e.g., XML instead of JSON)",
				"causes2": "Missing or incorrect Content-Type header",
				"checklist1": "Verify Accept header is checked",
				"checklist2": "Test with various Content-Type values"
			},
			"422": {
				"summary": "Unprocessable entity. The request is well-formed but semantically invalid.",
				"whenToUse1": "Validation errors in request body",
				"whenToUse2": "Business logic validation failed",
				"whenToUse3": "Semantic errors (e.g., invalid date range)",
				"causes1": "Field validation failed",
				"causes2": "Business rule violation",
				"causes3": "Invalid data relationships",
				"checklist1": "Verify error details specific fields",
				"checklist2": "Check error format includes field-level errors",
				"checklist3": "Test with various validation scenarios",
				"checklist4": "Ensure 422 is used, not 400 for validation"
			},
			"429": {
				"summary": "Too many requests. The user has sent too many requests in a given time.",
				"whenToUse1": "Rate limit exceeded",
				"whenToUse2": "Too many requests from same IP/user",
				"causes1": "Rate limit threshold exceeded",
				"causes2": "Too frequent API calls",
				"causes3": "DDoS protection triggered",
				"checklist1": "Verify Retry-After header is present",
				"checklist2": "Check error message includes rate limit info",
				"checklist3": "Test rate limiting behavior"
			},
			"500": {
				"summary": "Internal server error. The server encountered an unexpected condition.",
				"whenToUse1": "Unexpected server error",
				"whenToUse2": "Unhandled exception",
				"causes1": "Application code error",
				"causes2": "Database connection failure",
				"causes3": "Third-party service failure",
				"causes4": "Configuration error",
				"checklist1": "Verify error doesn't expose sensitive info",
				"checklist2": "Check requestId is included for debugging",
				"checklist3": "Ensure proper error logging"
			},
			"502": {
				"summary": "Bad gateway. The server acting as gateway received an invalid response.",
				"whenToUse1": "Invalid response from upstream server",
				"whenToUse2": "Upstream server error",
				"causes1": "Upstream server returned invalid response",
				"causes2": "Proxy/gateway configuration issue",
				"causes3": "Network issue between servers",
				"checklist1": "Verify error message is clear",
				"checklist2": "Check if retry is appropriate",
				"checklist3": "Test upstream server failures"
			},
			"503": {
				"summary": "Service unavailable. The server is temporarily unable to handle the request.",
				"whenToUse1": "Service temporarily down for maintenance",
				"whenToUse2": "Server overloaded",
				"whenToUse3": "Temporary unavailability",
				"causes1": "Scheduled maintenance",
				"causes2": "Server overload",
				"causes3": "Dependency service unavailable",
				"checklist1": "Verify Retry-After header if applicable",
				"checklist2": "Check error message explains unavailability",
				"checklist3": "Test service recovery scenarios"
			},
			"504": {
				"summary": "Gateway timeout. The server acting as gateway did not receive a timely response.",
				"whenToUse1": "Upstream server timeout",
				"whenToUse2": "Request took too long to process",
				"causes1": "Upstream server didn't respond in time",
				"causes2": "Network timeout",
				"causes3": "Slow upstream processing",
				"checklist1": "Verify timeout configuration",
				"checklist2": "Check if request can be optimized",
				"checklist3": "Test timeout scenarios"
			},
			"100": {
				"summary": "Continue. The server has received the request headers and the client should proceed to send the request body.",
				"whenToUse1": "Expect header indicates client will send body",
				"whenToUse2": "Large request body upload",
				"causes1": "Client sent Expect: 100-continue header",
				"causes2": "Server ready to receive request body",
				"checklist1": "Verify client handles 100 response",
				"checklist2": "Check request body is sent after 100"
			},
			"101": {
				"summary": "Switching Protocols. The server is switching protocols as requested by the client.",
				"whenToUse1": "Upgrading to WebSocket",
				"whenToUse2": "Protocol upgrade request",
				"causes1": "Client requested protocol upgrade",
				"checklist1": "Verify protocol upgrade is successful"
			},
			"202": {
				"summary": "Accepted. The request has been accepted for processing, but processing has not been completed.",
				"whenToUse1": "Asynchronous request processing",
				"whenToUse2": "Request queued for background processing",
				"causes1": "Request accepted but not yet processed",
				"checklist1": "Verify request is actually processed",
				"checklist2": "Check if status endpoint is provided"
			},
			"301": {
				"summary": "Moved permanently. The resource has been permanently moved to a new location.",
				"whenToUse1": "Resource permanently moved to new URL",
				"whenToUse2": "URL structure changed permanently",
				"causes1": "Resource location changed",
				"causes2": "Domain or path restructure",
				"checklist1": "Verify Location header points to new URL",
				"checklist2": "Check redirect is permanent"
			},
			"302": {
				"summary": "Found (temporary redirect). The resource is temporarily located at a different URL.",
				"whenToUse1": "Temporary resource relocation",
				"whenToUse2": "Temporary URL change",
				"causes1": "Resource temporarily moved",
				"causes2": "Maintenance or load balancing",
				"checklist1": "Verify Location header is present",
				"checklist2": "Check redirect method (GET vs POST)"
			},
			"304": {
				"summary": "Not modified. The resource has not been modified since the last request.",
				"whenToUse1": "Conditional GET with If-None-Match or If-Modified-Since",
				"whenToUse2": "Cached resource is still valid",
				"causes1": "Resource unchanged since last request",
				"checklist1": "Verify ETag or Last-Modified headers",
				"checklist2": "Check response body is empty"
			},
			"307": {
				"summary": "Temporary redirect. The request should be repeated with the same HTTP method.",
				"whenToUse1": "Temporary redirect preserving method",
				"whenToUse2": "Load balancing or maintenance",
				"causes1": "Temporary server relocation",
				"checklist1": "Verify HTTP method is preserved",
				"checklist2": "Check Location header"
			},
			"308": {
				"summary": "Permanent redirect. The request and all future requests should be repeated using the provided URI.",
				"whenToUse1": "Permanent redirect preserving method",
				"whenToUse2": "Permanent URL change",
				"causes1": "Permanent resource relocation",
				"checklist1": "Verify method and body are preserved",
				"checklist2": "Check redirect is truly permanent"
			},
			"405": {
				"summary": "Method not allowed. The HTTP method is not allowed for the requested resource.",
				"whenToUse1": "HTTP method not supported for endpoint",
				"whenToUse2": "Endpoint exists but method is wrong",
				"causes1": "Method not implemented for resource",
				"causes2": "Only specific methods allowed",
				"checklist1": "Verify Allow header lists allowed methods",
				"checklist2": "Test with various HTTP methods"
			},
			"408": {
				"summary": "Request timeout. The server timed out waiting for the request.",
				"whenToUse1": "Client took too long to send request",
				"whenToUse2": "Request timeout before completion",
				"causes1": "Client didn't send request in time",
				"causes2": "Network connection timeout",
				"checklist1": "Verify timeout configuration",
				"checklist2": "Test with slow connections"
			},
			"410": {
				"summary": "Gone. The resource is no longer available and will not be available again.",
				"whenToUse1": "Resource permanently deleted",
				"whenToUse2": "Resource removed and won't return",
				"causes1": "Resource permanently removed",
				"causes2": "Resource expired and deleted",
				"checklist1": "Verify resource won't be restored",
				"checklist2": "Check error message explains deletion"
			},
			"412": {
				"summary": "Precondition failed. One or more conditions in the request header fields evaluated to false.",
				"whenToUse1": "If-Match or If-None-Match condition failed",
				"whenToUse2": "If-Unmodified-Since condition failed",
				"causes1": "ETag mismatch",
				"causes2": "Resource modified since last request",
				"checklist1": "Verify precondition headers",
				"checklist2": "Test optimistic locking scenarios"
			},
			"413": {
				"summary": "Payload too large. The request entity is larger than limits defined by the server.",
				"whenToUse1": "Request body exceeds size limit",
				"whenToUse2": "File upload too large",
				"causes1": "Payload exceeds server limit",
				"causes2": "File size too large",
				"checklist1": "Verify size limit is documented",
				"checklist2": "Test with various payload sizes"
			},
			"501": {
				"summary": "Not implemented. The server does not support the functionality required to fulfill the request.",
				"whenToUse1": "Feature not yet implemented",
				"whenToUse2": "Method not supported by server",
				"causes1": "Endpoint or feature not available",
				"checklist1": "Verify feature is truly not implemented",
				"checklist2": "Check if 404 is more appropriate"
			}
		}
	},
	"userAgentParser": {
		"title": "User Agent Parser - QA Toolbox",
		"description": "Parse User-Agent strings to extract browser, OS, device, and version information locally."
	},
	"headersInspector": {
		"title": "Headers Inspector - QA Toolbox",
		"description": "Parse and analyze HTTP headers. Understand what each header does, detect common issues, and get quick copy actions.",
		"heading": "Headers Inspector",
		"subtitle": "Parse raw HTTP headers, understand their purpose, and detect common configuration issues.",
		"inputLabel": "Raw Headers",
		"placeholder": "Paste headers from DevTools or curl output...\n\nExample:\nContent-Type: application/json\nAuthorization: Bearer token123",
		"typeLabel": "Type:",
		"typeRequest": "Request",
		"typeResponse": "Response",
		"autoParse": "Auto-parse",
		"parse": "Parse",
		"reset": "Reset",
		"example": "Example",
		"exampleRequest": "Request Headers",
		"exampleResponse": "Response Headers",
		"exampleCors": "CORS Error Example",
		"exampleCookie": "Cookie Issue Example",
		"headersList": "Headers",
		"noHeaders": "Paste headers above and click Parse to get started.",
		"details": {
			"whatItDoes": "What it does",
			"whenToUse": "When to use",
			"commonMistakes": "Common mistakes",
			"securityNotes": "Security notes",
			"quickActions": "Quick actions",
			"copyName": "Copy name",
			"copyValue": "Copy value",
			"copyFull": "Copy header:value",
			"selectHeader": "Select a header to view details",
			"noInfo": "No information available for this header.",
			"recommendation": "Recommendation:",
			"hints": {
				"cacheValidationMissing": "Consider adding ETag or Last-Modified for cache validation.",
				"sameSiteNoneSecure": "Add Secure flag when using SameSite=None.",
				"cannotUseStarWithCredentials": "Cannot use \"*\" with credentials. Use a specific origin instead.",
				"requiresSpecificAcao": "Requires a specific Access-Control-Allow-Origin (not \"*\")."
			},
			"duplicates": "duplicates"
		},
		"issues": {
			"detectedIssues": "Detected Issues",
			"showDetectedIssues": "Show Detected Issues",
			"errors": "errors",
			"warnings": "warnings",
			"info": "info",
			"showOnlyErrors": "Show only errors",
			"hideIssues": "Hide issues",
			"less": "Less",
			"more": "More",
			"corsStarWithCredentials": "Invalid CORS: ACAO=\"*\" with ACAC=\"true\"",
			"corsStarWithCredentialsWhy": "CORS specification doesn't allow wildcard origin with credentials. Use specific origin instead.",
			"corsVaryOrigin": "Recommend Vary: Origin when using specific ACAO with credentials",
			"corsVaryOriginWhy": "When using specific origin with credentials, add Vary: Origin to ensure proper caching behavior.",
			"corsMissingAcao": "CORS request detected but no ACAO header in response",
			"corsMissingAcaoWhy": "Request includes Origin header but response doesn't specify allowed origins.",
			"cacheNoStoreWithEtag": "Cache-Control: no-store with ETag may be redundant",
			"cacheNoStoreWithEtagWhy": "no-store prevents caching, so ETag validation is unnecessary.",
			"cacheMissingForApi": "API response (JSON) missing Cache-Control header",
			"cacheMissingForApiWhy": "API responses should explicitly specify caching behavior.",
			"securityMissingHsts": "HTTPS detected but missing HSTS header",
			"securityMissingHstsWhy": "HSTS helps prevent protocol downgrade attacks.",
			"securityMissingXContentType": "HTML content missing X-Content-Type-Options header",
			"securityMissingXContentTypeWhy": "Prevents MIME type sniffing attacks.",
			"cookieSameSiteNoneNoSecure": "Set-Cookie: SameSite=None requires Secure flag",
			"cookieSameSiteNoneNoSecureWhy": "SameSite=None cookies must be marked Secure to prevent interception.",
			"cookieMissingHttpOnly": "Session-like cookie missing HttpOnly flag",
			"cookieMissingHttpOnlyWhy": "HttpOnly prevents JavaScript access, reducing XSS attack surface."
		},
		"headers": {
			"authorization": {
				"description": "Contains credentials for authenticating the client with the server.",
				"whenToUse1": "Bearer tokens for API authentication",
				"whenToUse2": "Basic authentication credentials",
				"mistakes1": "Sending tokens in query parameters instead",
				"mistakes2": "Not using HTTPS for sensitive credentials",
				"security": "Always use HTTPS when sending credentials. Consider token expiration and rotation."
			},
			"wwwAuthenticate": {
				"description": "Indicates the authentication scheme required for access.",
				"whenToUse1": "401 Unauthorized responses to indicate required auth",
				"mistakes1": "Missing on 401 responses"
			},
			"contentType": {
				"description": "Indicates the media type of the resource.",
				"whenToUse1": "Request body content type (POST, PUT, PATCH)",
				"whenToUse2": "Response body content type",
				"mistakes1": "Missing charset for text types",
				"mistakes2": "Incorrect MIME type (e.g., application/json vs text/json)"
			},
			"accept": {
				"description": "Specifies media types acceptable for the response.",
				"whenToUse1": "Client indicates preferred response format",
				"mistakes1": "Not specifying Accept header when format matters"
			},
			"acceptEncoding": {
				"description": "Specifies supported compression methods.",
				"whenToUse1": "To reduce response size",
				"mistakes1": "No compression enabled",
				"mistakes2": "Server ignores header",
				"security": "Compression can affect certain attacks."
			},
			"acceptLanguage": {
				"description": "Defines preferred client languages.",
				"whenToUse1": "For response localization",
				"mistakes1": "No default language fallback",
				"mistakes2": "Server ignores header",
				"security": "Can be used for fingerprinting."
			},
			"contentEncoding": {
				"description": "Indicates encoding transformations applied to the message body.",
				"whenToUse1": "Compressed responses (gzip, br, deflate)",
				"mistakes1": "Not matching Content-Encoding with actual encoding"
			},
			"contentLength": {
				"description": "Size of the message body in bytes.",
				"whenToUse1": "Request/response body size indication",
				"mistakes1": "Incorrect length causing connection issues"
			},
			"cacheControl": {
				"description": "Directives for caching mechanisms in requests and responses.",
				"whenToUse1": "Control caching behavior (public, private, no-cache, max-age)",
				"whenToUse2": "API responses that should not be cached",
				"mistakes1": "Caching sensitive data",
				"mistakes2": "Missing Cache-Control on API responses"
			},
			"etag": {
				"description": "Entity tag for cache validation.",
				"whenToUse1": "Conditional requests and cache validation",
				"mistakes1": "Weak ETags when strong ETags are needed"
			},
			"lastModified": {
				"description": "Indicates when the resource was last modified.",
				"whenToUse1": "For caching and conditional requests",
				"mistakes1": "Missing for static resources",
				"mistakes2": "Invalid date format",
				"security": "May reveal resource update patterns."
			},
			"ifNoneMatch": {
				"description": "Conditional request using ETag for cache validation.",
				"whenToUse1": "Check if resource changed since last request",
				"mistakes1": "Not handling 304 Not Modified responses"
			},
			"expires": {
				"description": "Date/time after which the response is considered stale.",
				"whenToUse1": "Legacy cache expiration (prefer Cache-Control)",
				"mistakes1": "Using Expires instead of Cache-Control"
			},
			"vary": {
				"description": "Headers that affect response selection.",
				"whenToUse1": "CORS responses with credentials and specific origin",
				"mistakes1": "Missing Vary: Origin when needed"
			},
			"origin": {
				"description": "Origin of the request (scheme, host, port).",
				"whenToUse1": "CORS requests from browsers"
			},
			"accessControlAllowOrigin": {
				"description": "Specifies allowed origins for CORS requests.",
				"whenToUse1": "CORS-enabled API responses",
				"mistakes1": "Using * with credentials (not allowed)",
				"mistakes2": "Not validating origin on server side"
			},
			"accessControlAllowCredentials": {
				"description": "Indicates if credentials can be included in CORS requests.",
				"whenToUse1": "CORS requests that need cookies or auth headers",
				"mistakes1": "Setting true with ACAO=\"*\" (invalid)"
			},
			"accessControlAllowHeaders": {
				"description": "Headers allowed in CORS requests.",
				"whenToUse1": "CORS preflight responses"
			},
			"accessControlAllowMethods": {
				"description": "HTTP methods allowed in CORS requests.",
				"whenToUse1": "CORS preflight responses"
			},
			"accessControlExposeHeaders": {
				"description": "Headers exposed to JavaScript in CORS responses.",
				"whenToUse1": "CORS responses exposing custom headers"
			},
			"accessControlMaxAge": {
				"description": "Defines how long CORS preflight results are cached.",
				"whenToUse1": "To reduce OPTIONS requests",
				"mistakes1": "Not set",
				"mistakes2": "Excessively high value",
				"security": "CORS changes may apply with delay."
			},
			"setCookie": {
				"description": "Sets a cookie in the browser.",
				"whenToUse1": "Session management, preferences, tracking",
				"mistakes1": "SameSite=None without Secure",
				"mistakes2": "Missing HttpOnly for session cookies",
				"mistakes3": "Not setting appropriate expiration",
				"security": "Use HttpOnly for session cookies, Secure for HTTPS-only, and appropriate SameSite values."
			},
			"cookie": {
				"description": "Contains stored cookies for the domain.",
				"whenToUse1": "Sending cookies with requests"
			},
			"contentSecurityPolicy": {
				"description": "Controls resources the browser can load to prevent XSS.",
				"whenToUse1": "Web pages that need XSS protection",
				"mistakes1": "Too restrictive policy breaking functionality",
				"security": "Start with default-src 'self' and gradually add needed sources."
			},
			"strictTransportSecurity": {
				"description": "Forces HTTPS connections for the domain.",
				"whenToUse1": "HTTPS-only sites",
				"mistakes1": "Including subdomains when not ready",
				"security": "Use max-age of at least 31536000 (1 year) and includeSubDomains when appropriate."
			},
			"xFrameOptions": {
				"description": "Prevents clickjacking attacks by controlling framing.",
				"whenToUse1": "Pages that should not be embedded in iframes",
				"mistakes1": "Using DENY when SAMEORIGIN is sufficient"
			},
			"xContentTypeOptions": {
				"description": "Prevents MIME type sniffing attacks.",
				"whenToUse1": "All HTML responses",
				"mistakes1": "Missing on HTML content"
			},
			"referrerPolicy": {
				"description": "Controls referrer information sent with requests.",
				"whenToUse1": "Privacy-sensitive applications"
			},
			"permissionsPolicy": {
				"description": "Controls browser features and APIs available to the page.",
				"whenToUse1": "Restricting access to browser features"
			},
			"location": {
				"description": "URL for redirection responses.",
				"whenToUse1": "3xx redirect responses",
				"mistakes1": "Relative URLs when absolute is needed"
			},
			"retryAfter": {
				"description": "Time to wait before retrying the request.",
				"whenToUse1": "429 Too Many Requests or 503 Service Unavailable"
			},
			"xForwardedFor": {
				"description": "Original client IP address when behind proxy.",
				"whenToUse1": "Proxied requests",
				"mistakes1": "Trusting without validation (security risk)"
			},
			"xForwardedProto": {
				"description": "Original protocol (http/https) when behind proxy.",
				"whenToUse1": "Proxied requests"
			},
			"forwarded": {
				"description": "Standardized proxy information (replaces X-Forwarded-*).",
				"whenToUse1": "Proxied requests (prefer over X-Forwarded-*)"
			},
			"serverTiming": {
				"description": "Performance metrics from the server.",
				"whenToUse1": "Performance monitoring and debugging"
			},
			"referer": {
				"description": "Provides the URL of the request origin.",
				"whenToUse1": "For analytics and request tracing",
				"mistakes1": "Using it for security checks",
				"mistakes2": "Expecting it when blocked by policy",
				"security": "May leak sensitive URLs."
			},
			"userAgent": {
				"description": "Identifies the client or browser.",
				"whenToUse1": "For debugging and analytics",
				"mistakes1": "Access logic based on User-Agent",
				"security": "Easily spoofed."
			},
			"pragma": {
				"description": "Legacy HTTP/1.0 cache control directive. Use Cache-Control instead.",
				"whenToUse1": "Legacy compatibility (prefer Cache-Control)",
				"mistakes1": "Using Pragma instead of Cache-Control"
			},
			"date": {
				"description": "Date and time when the message was originated.",
				"whenToUse1": "HTTP responses to indicate message origination time",
				"mistakes1": "Incorrect server time can cause cache TTL issues and problems with signatures (JWT, signed URLs)"
			},
			"server": {
				"description": "Information about the server software handling the request.",
				"whenToUse1": "Server identification and debugging",
				"mistakes1": "Revealing sensitive server version information"
			},
			"xEnvoyUpstreamServiceTime": {
				"description": "Time in milliseconds taken by the upstream service, added by Envoy proxy.",
				"whenToUse1": "Performance monitoring in Envoy-based architectures",
				"mistakes1": "Confusing with total response time in browser — this is only part of the path (without client, TLS, network, etc.)"
			},
			"xXssProtection": {
				"description": "Enables XSS filter in older browsers (IE, older Chrome). Deprecated, use Content-Security-Policy instead.",
				"whenToUse1": "Legacy browser support (deprecated)",
				"mistakes1": "Using X-XSS-Protection instead of Content-Security-Policy",
				"security": "Often set to X-XSS-Protection: 0 to disable old filters that sometimes made things worse."
			}
		},
		"whatIs": "What is Headers Inspector?",
		"whatIsDescription": "Headers Inspector is a local tool that parses raw HTTP request/response headers into a readable list with explanations and common pitfalls. It helps you spot misconfigurations in CORS, caching, content types, and cookies during API debugging and QA testing — directly in your browser.",
		"whatYouCanDo": "What you can do here",
		"whatYouCanDo1": "Paste raw headers and instantly parse them into key/value pairs",
		"whatYouCanDo2": "Switch between Request and Response modes",
		"whatYouCanDo3": "See detected issues with severity (error/warning/info) and suggested fixes",
		"whatYouCanDo4": "Open each header to view meaning, usage, and typical mistakes",
		"whatYouCanDo5": "Copy header name/value or full Header: value line",
		"privacy": "Privacy",
		"privacyText": "All data is processed locally in your browser. No data is sent to any server."
	},
	"privacy": {
		"title": "Privacy - QA Toolbox",
		"description": "Privacy policy for QA Toolbox. We don't collect, store, or transmit any data."
	}
}
