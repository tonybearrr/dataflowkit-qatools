{
	"common": {
		"qaToolbox": "QA Toolbox",
		"madeBy": "Створено Антоном",
		"donate": "Підтримати",
		"privacy": "Політика конфіденційності",
		"about": "Про проєкт",
		"privacyFirst": "Працює локально у вашому браузері. Без відстеження. Без облікових записів.",
		"noTracking": "Без відстеження",
		"localOnly": "Тільки локально",
		"builtBy": "Частина",
		"moreToolsComing": "Більше інструментів незабаром...",
		"copy": "Копіювати",
		"clear": "Очистити",
		"parse": "Розпарсити"
	},
	"nav": {
		"testDataGenerator": "Тестові дані",
		"apiResponseValidator": "Валідатор API",
		"statusCodeReference": "Статус-коди",
		"userAgentParser": "User Agent"
	},
	"home": {
		"title": "QA Toolbox",
		"description": "Швидкі інструменти для QA-тестування з пріоритетом конфіденційності. Без бекенду. Без відстеження. Все працює локально у вашому браузері.",
		"testDataGenerator": {
			"title": "Генератор тестових даних",
			"description": "Генеруйте тестові дані: email, номери телефонів, UUID, імена, адреси та інше.",
			"tags": ["Email", "Телефон", "UUID"]
		},
		"apiResponseValidator": {
			"title": "Валідатор відповідей API",
			"description": "Валідуйте JSON-відповіді за схемою. Перевіряйте структуру, типи та обов'язкові поля.",
			"tags": ["JSON Schema", "Валідація", "API"]
		},
		"statusCodeReference": {
			"title": "Довідник статус-кодів",
			"description": "Швидкий довідник HTTP статус-кодів з описом та прикладами використання.",
			"tags": ["HTTP", "Статус", "Довідник"]
		},
		"userAgentParser": {
			"title": "Парсер User-Agent",
			"description": "Розпарсуйте рядки User-Agent для витягування інформації про браузер, ОС, пристрій та версію.",
			"tags": ["Браузер", "ОС", "Пристрій"]
		}
	},
	"testDataGenerator": {
		"title": "Генератор тестових даних - QA Toolbox",
		"description": "Генеруйте тестові дані локально: email, номери телефонів, UUID, імена, адреси та інше. Дані не відправляються на сервери.",
		"heading": "Генератор тестових даних",
		"subtitle": "Test Data Generator — інструмент для генерації тестових даних без бекенду. Дозволяє задати схему даних, переглянути результат і експортувати його у JSON або CSV для тестування, API та розробки.",
		"whatIsTestData": "Що таке генерація тестових даних?",
		"testDataDescription": "Генерація тестових даних — це процес створення реалістичних, структурованих даних для тестування. Цей інструмент дозволяє визначити схему з різними типами полів (рядки, числа, дати, email тощо) та генерувати кілька рядків даних, які відповідають вашим вимогам.",
		"parameters": "Параметри",
		"presets": "Пресети",
		"presetsDescription": "Готові шаблони схем:",
		"presetsList": "User, Order, Address, Event",
		"fields": "Поля",
		"fieldName": "Назва поля — ключ у фінальному результаті",
		"fieldType": "Тип — тип даних (uuid, email, name, phone, address, date, string)",
		"fieldRequired": "Обовʼязкове — поле завжди присутнє",
		"fieldManage": "Порядок / Дублювання / Видалення — керування структурою",
		"preview": "Попередній перегляд",
		"previewDescription": "Таблиця згенерованих даних",
		"previewRegenerate": "Regenerate — створити нові дані з тією ж схемою",
		"export": "Експорт",
		"exportRows": "Rows — кількість рядків",
		"exportSeed": "Seed — фіксоване значення для повторюваних результатів",
		"exportFormat": "Формат — JSON або CSV",
		"exportArrayKey": "Array key (необовʼязково) — обгортає масив в обʼєкт",
		"exportActions": "Copy / Download — копіювання або завантаження",
		"features": "Можливості",
		"featureSchema": "Визначення користувацьких схем з різними типами полів",
		"featureSeed": "Використання seed для відтворюваних, детермінованих даних",
		"featureExport": "Експорт у формати JSON або CSV",
		"featureLocal": "Вся обробка відбувається локально у вашому браузері",
		"useCases": "Сценарії використання",
		"useCase1": "Створення тестових наборів даних для тестування API",
		"useCase2": "Генерація зразкових даних для заповнення бази даних",
		"useCase3": "Створення мок-даних для фронтенд розробки",
		"useCase4": "Створення тестових фікстур для автоматизованого тестування",
		"privacy": "Приватність",
		"privacyText": "Усі дані генеруються локально у браузері. Дані не передаються на сервер.",
		"confirmReplaceTitle": "Замінити схему?",
		"confirmReplaceMessage": "Це замінить вашу поточну схему. Продовжити?",
		"confirmCancel": "Скасувати",
		"confirmContinue": "Продовжити"
	},
	"payloadBuilder": {
		"title": "Payload Builder - QA Toolbox",
		"description": "Створюйте та ламайте JSON payload для тестування API. Генеруйте невалідні варіанти для тестування валідації.",
		"heading": "Payload Builder + Breaker",
		"subtitle": "Створюйте JSON payload візуально або в коді. Генеруйте невалідні варіанти для тестування валідації API.",
		"whatIsPayloadBuilder": "Що таке Payload Builder + Breaker?",
		"payloadBuilderDescription": "Payload Builder + Breaker — це локальний інструмент для створення та навмисного ламання JSON payload'ів для тестування API. Створюйте валідні payload'и візуально або в JSON і генеруйте невалідні варіанти для перевірки валідації та обробки помилок. Усі операції виконуються локально у вашому браузері.",
		"parameters": "Параметри",
		"templates": "Шаблони",
		"templatesDescription": "Готові payload'и для типових API-запитів",
		"templatesList": "",
		"jsonEditor": "JSON Editor",
		"jsonEditorDescription": "Редагування, форматування та мінімізація JSON з валідацією",
		"treeBuilder": "Tree Builder",
		"treeBuilderDescription": "Візуальне створення JSON-структур",
		"breaker": "Варіанти (Breaker)",
		"breakerDescription": "Генерація помилкових payload'ів (відсутні поля, неправильні типи, null, edge cases)",
		"breakerPresets": "",
		"breakerPresetsList": "",
		"output": "Output",
		"outputDescription": "Перегляд, порівняння, копіювання або експорт payload'ів",
		"privacy": "Приватність",
		"privacyText": "Усі дані обробляються локально у вашому браузері. Дані не відправляються на сервер."
	},
	"apiResponseValidator": {
		"title": "Валідатор відповідей API - QA Toolbox",
		"description": "API Validator — це інструмент для розробників і QA-інженерів, який дозволяє перевіряти відповідність JSON-payload очікуваному контракту, описаному за допомогою JSON Schema. Він підсвічує помилки валідації, проблеми зі схемою та форматуванням, допомагаючи виявити помилки ще до відправки запиту на бекенд. Уся перевірка виконується локально у браузері — швидко та без передачі даних на сервер.",
		"heading": "API Validator",
		"subtitle": "API Validator допомагає перевіряти JSON-payload запитів відповідно до JSON Schema прямо у вашому браузері. Швидко виявляйте невідповідності схемі, некоректні типи даних і відсутні обовʼязкові поля під час розробки API та QA-тестування.",
		"payloadLabel": "Payload JSON",
		"outputLabel": "Output",
		"schemaLabel": "Schema JSON",
		"validate": "Валідувати",
		"autoValidate": "Авто-валідація",
		"formatPayload": "Форматувати Payload",
		"formatSchema": "Форматувати Schema",
		"selectPreset": "Sample Schema",
		"reset": "Скинути",
		"valid": "Валідний",
		"invalid": "Невалідний",
		"parseError": "Помилка парсингу",
		"schemaParseError": "Помилка парсингу Schema",
		"line": "Рядок",
		"column": "Колонка",
		"error": "помилка",
		"errors": "помилок",
		"keyword": "Ключове слово",
		"expected": "Очікувалось",
		"received": "Отримано",
		"copy": "Копіювати",
		"copied": "Скопійовано!",
		"copyError": "Копіювати помилку",
		"noValidation": "Натисніть Валідувати для перевірки JSON за схемою",
		"formattedOutput": "Відформатований вивід",
		"whatIs": "Що таке API Validator?",
		"parameters": "Параметри",
		"payloadDesc": "JSON payload для валідації",
		"schemaDesc": "JSON Schema (draft 2020-12 або draft-07)",
		"autoValidateDesc": "Автоматично валідувати при зміні вводу",
		"presets": "Presets",
		"presetsDesc": "Готові схеми та payload'и для типових API-запитів",
		"format": "Форматування",
		"formatDesc": "Форматувати JSON з правильними відступами",
		"privacy": "Приватність",
		"privacyText": "Уся валідація відбувається локально у вашому браузері. Дані не відправляються на сервер.",
		"useCases": "Сценарії використання",
		"useCasesSubtitle": "Використовуйте API Validator для:",
		"useCase1": "перевірки JSON запитів перед відправкою на бекенд",
		"useCase2": "тестування серверної валідації під час QA",
		"useCase3": "пошуку помилок у схемі або payload-i",
		"useCase4": "перевірки обов'язкових полів, типів та форматів даних",
		"whyUse": "Навіщо використовувати цей інструмент?",
		"whyUse1": "Миттєвий фідбек для АРІ payload-ів",
		"whyUse2": "Підтримка JSON Schema (draft-07, draft-2020-12)",
		"whyUse3": "Підходить для розробників і QA інженерів",
		"typicalWorkflow": "Типовий флоу",
		"workflow1": "Вставте або введіть JSON payload",
		"workflow2": "Додайте або оберіть JSON Schema",
		"workflow3": "Натисніть Validate або увімкніть авто-валідацію",
		"workflow4": "Перегляньте помилки або підтвердження валідності",
		"workflow5": "За потреби скопіюйте відформатований результат"
	},
	"statusCodeReference": {
		"title": "HTTP Status Codes Explorer - QA Toolbox",
		"description": "Швидкий локальний довідник HTTP статус-кодів з описом, прикладами використання та шаблонами API відповідей.",
		"heading": "HTTP Status Codes Explorer",
		"subtitle": "Швидкий довідник HTTP статус-кодів з описом, прикладами використання та рекомендованими API відповідями.",
		"searchPlaceholder": "Пошук за кодом або ключовим словом...",
		"categoryAll": "Всі",
		"category1xx": "1xx",
		"category2xx": "2xx",
		"category3xx": "3xx",
		"category4xx": "4xx",
		"category5xx": "5xx",
		"commonOnly": "Тільки поширені",
		"categoryLabel": {
			"informational": "Інформаційні",
			"success": "Успіх",
			"redirection": "Перенаправлення",
			"clientError": "Помилка клієнта",
			"serverError": "Помилка сервера"
		},
		"whenToUse": "Коли використовувати",
		"commonCauses": "Типові причини",
		"whatToReturn": "Що повертати",
		"testingChecklist": "Чек-лист для тестування",
		"relatedCodes": "Пов'язані коди",
		"copyJson": "Копіювати JSON",
		"copyTitle": "Копіювати заголовок",
		"copied": "Скопійовано!",
		"noResults": "Нічого не знайдено",
		"noResultsSuggestion": "Спробуйте пошук: 404, not found, rate limit, unauthorized",
		"whatIs": "Що таке HTTP Status Codes Explorer?",
		"whatIsDescription": "HTTP Status Codes Explorer — це локальний інструмент для швидкого розуміння HTTP статус-кодів, їх типових причин та рекомендованих API відповідей. Допомагає QA інженерам, розробникам та бекенд інженерам приймати обґрунтовані рішення щодо вибору статус-кодів та структури відповідей про помилки.",
		"qaUsage": "Як QA використовує статус-коди в тестуванні API",
		"qaUsageDescription": "QA інженери використовують статус-коди для перевірки поведінки API, тестування обробки помилок та забезпечення правильних форматів відповідей. Цей інструмент допомагає визначити правильний статус-код для різних сценаріїв та надає приклади відповідей для тестування.",
		"commonMistakes": "Типові помилки: 401 vs 403, 409 vs 422, 502 vs 504",
		"commonMistakesDescription": "401 (Unauthorized) означає, що аутентифікація відсутня або невалідна, тоді як 403 (Forbidden) означає, що користувач аутентифікований, але не має дозволу. 409 (Conflict) вказує на конфлікт стану, тоді як 422 (Unprocessable Entity) означає, що запит правильно сформований, але семантично невалідний. 502 (Bad Gateway) — це помилка upstream сервера, тоді як 504 (Gateway Timeout) означає, що upstream сервер не відповів вчасно.",
		"statusCodes": {
			"100": {
				"summary": "Продовжити. Сервер отримав заголовки запиту, і клієнт повинен продовжити надсилання тіла запиту.",
				"whenToUse1": "Заголовок Expect вказує, що клієнт надішле тіло",
				"whenToUse2": "Велике завантаження тіла запиту",
				"causes1": "Клієнт надіслав заголовок Expect: 100-continue",
				"causes2": "Сервер готовий отримати тіло запиту",
				"checklist1": "Перевірте, що клієнт обробляє відповідь 100",
				"checklist2": "Перевірте, що тіло запиту надсилається після 100"
			},
			"101": {
				"summary": "Перемикання протоколів. Сервер перемикає протоколи за запитом клієнта.",
				"whenToUse1": "Оновлення до WebSocket",
				"whenToUse2": "Запит на оновлення протоколу",
				"causes1": "Клієнт запросив оновлення протоколу",
				"checklist1": "Перевірте, що оновлення протоколу успішне"
			},
			"200": {
				"summary": "Запит успішний. Стандартна відповідь для успішних HTTP запитів.",
				"whenToUse1": "Успішні GET, PUT або PATCH запити",
				"whenToUse2": "Повернення даних у тілі відповіді",
				"whenToUse3": "Стандартна успішна відповідь",
				"causes1": "Нормальна успішна обробка запиту",
				"causes2": "Ресурс успішно отримано або оновлено",
				"checklist1": "Перевірте, що тіло відповіді містить очікувані дані",
				"checklist2": "Перевірте, що заголовок Content-Type відповідає формату відповіді",
				"checklist3": "Переконайтеся, що відповідь правильно відформатована"
			},
			"201": {
				"summary": "Ресурс успішно створено. Зазвичай використовується після POST запитів, які створюють нові ресурси.",
				"whenToUse1": "Після успішного POST запиту, що створює новий ресурс",
				"whenToUse2": "Коли повертається створений ресурс у тілі відповіді",
				"causes1": "Новий ресурс успішно створено",
				"causes2": "Створення ресурсу з заголовком Location",
				"checklist1": "Перевірте, що заголовок Location вказує на новий ресурс",
				"checklist2": "Перевірте, що тіло відповіді містить створений ресурс",
				"checklist3": "Переконайтеся, що ID ресурсу включено"
			},
			"204": {
				"summary": "Запит успішний, але немає вмісту для повернення. Використовується для успішних операцій, які не потребують тіла відповіді.",
				"whenToUse1": "Успішні DELETE запити",
				"whenToUse2": "Успішні PUT/PATCH без необхідності відповіді",
				"causes1": "Операція успішно завершена без вмісту",
				"checklist1": "Перевірте, що тіло відповіді порожнє",
				"checklist2": "Перевірте, що операція дійсно успішна"
			},
			"202": {
				"summary": "Прийнято. Запит прийнято для обробки, але обробка ще не завершена.",
				"whenToUse1": "Асинхронна обробка запиту",
				"whenToUse2": "Запит поставлено в чергу для фонової обробки",
				"causes1": "Запит прийнято, але ще не оброблено",
				"checklist1": "Перевірте, що запит дійсно обробляється",
				"checklist2": "Перевірте, чи надано кінцеву точку статусу"
			},
			"301": {
				"summary": "Переміщено назавжди. Ресурс було постійно переміщено на нову адресу.",
				"whenToUse1": "Ресурс постійно переміщено на новий URL",
				"whenToUse2": "Структура URL змінена назавжди",
				"causes1": "Місце розташування ресурсу змінено",
				"causes2": "Реструктуризація домену або шляху",
				"checklist1": "Перевірте, що заголовок Location вказує на новий URL",
				"checklist2": "Перевірте, що перенаправлення постійне"
			},
			"302": {
				"summary": "Знайдено (тимчасове перенаправлення). Ресурс тимчасово розташований за іншою адресою.",
				"whenToUse1": "Тимчасове переміщення ресурсу",
				"whenToUse2": "Тимчасова зміна URL",
				"causes1": "Ресурс тимчасово переміщено",
				"causes2": "Обслуговування або балансування навантаження",
				"checklist1": "Перевірте, що заголовок Location присутній",
				"checklist2": "Перевірте метод перенаправлення (GET vs POST)"
			},
			"304": {
				"summary": "Не змінено. Ресурс не змінювався з моменту останнього запиту.",
				"whenToUse1": "Умовний GET з If-None-Match або If-Modified-Since",
				"whenToUse2": "Кешований ресурс все ще валідний",
				"causes1": "Ресурс не змінювався з моменту останнього запиту",
				"checklist1": "Перевірте заголовки ETag або Last-Modified",
				"checklist2": "Перевірте, що тіло відповіді порожнє"
			},
			"307": {
				"summary": "Тимчасове перенаправлення. Запит повинен бути повторений з тим самим HTTP методом.",
				"whenToUse1": "Тимчасове перенаправлення зі збереженням методу",
				"whenToUse2": "Балансування навантаження або обслуговування",
				"causes1": "Тимчасове переміщення сервера",
				"checklist1": "Перевірте, що HTTP метод збережено",
				"checklist2": "Перевірте заголовок Location"
			},
			"308": {
				"summary": "Постійне перенаправлення. Запит і всі майбутні запити повинні бути повторені з використанням наданого URI.",
				"whenToUse1": "Постійне перенаправлення зі збереженням методу",
				"whenToUse2": "Постійна зміна URL",
				"causes1": "Постійне переміщення ресурсу",
				"checklist1": "Перевірте, що метод і тіло збережено",
				"checklist2": "Перевірте, що перенаправлення дійсно постійне"
			},
			"400": {
				"summary": "Невірний синтаксис запиту або параметри. Сервер не може обробити запит через помилку клієнта.",
				"whenToUse1": "Невірний синтаксис запиту",
				"whenToUse2": "Невірні параметри запиту",
				"whenToUse3": "Відсутні обов'язкові поля",
				"causes1": "Невірний синтаксис JSON",
				"causes2": "Відсутні обов'язкові параметри",
				"causes3": "Невірні типи параметрів",
				"causes4": "Невірно сформоване тіло запиту",
				"checklist1": "Перевірте, що повідомлення про помилку пояснює проблему",
				"checklist2": "Перевірте, що відповідь про помилку включає requestId",
				"checklist3": "Переконайтеся, що формат помилки узгоджений",
				"checklist4": "Тестуйте з різними невалідними входами"
			},
			"401": {
				"summary": "Потрібна аутентифікація або вона не вдалася. Клієнт повинен аутентифікуватися для отримання запитуваної відповіді.",
				"whenToUse1": "Відсутній або невалідний токен аутентифікації",
				"whenToUse2": "Термін дії облікових даних аутентифікації закінчився",
				"whenToUse3": "Схема аутентифікації не підтримується",
				"causes1": "Заголовок Authorization не надано",
				"causes2": "Невалідний або застарілий токен",
				"causes3": "Облікові дані аутентифікації невірні",
				"checklist1": "Перевірте, що заголовок WWW-Authenticate присутній",
				"checklist2": "Перевірте, що повідомлення про помилку не розкриває чутливу інформацію",
				"checklist3": "Тестуйте з відсутніми, невалідними та застарілими токенами",
				"checklist4": "Переконайтеся, що використовується 401, а не 403 для проблем з аутентифікацією"
			},
			"403": {
				"summary": "Доступ заборонено. Клієнт не має дозволу на доступ до ресурсу.",
				"whenToUse1": "Користувач аутентифікований, але не має дозволу",
				"whenToUse2": "Ресурс існує, але доступ заборонено",
				"whenToUse3": "Недостатньо привілеїв для операції",
				"causes1": "Користувач не має необхідних дозволів",
				"causes2": "Доступ до ресурсу обмежено політикою",
				"causes3": "Операція не дозволена для ролі користувача",
				"checklist1": "Перевірте, що користувач аутентифікований (не 401)",
				"checklist2": "Перевірте, що повідомлення про помилку пояснює проблему з дозволами",
				"checklist3": "Тестуйте з різними ролями користувачів"
			},
			"404": {
				"summary": "Ресурс не знайдено. Сервер не може знайти запитуваний ресурс.",
				"whenToUse1": "Ресурс не існує",
				"whenToUse2": "Невірний ID ресурсу або шлях",
				"whenToUse3": "Кінцева точка не існує",
				"causes1": "Ресурс було видалено",
				"causes2": "Невірний URL або ID ресурсу",
				"causes3": "Ресурс ніколи не існував",
				"causes4": "Помилка в шляху запиту",
				"checklist1": "Перевірте, що повідомлення про помилку зрозуміле",
				"checklist2": "Перевірте, що відповідь не розкриває внутрішню структуру",
				"checklist3": "Тестуйте з різними невалідними ID"
			},
			"405": {
				"summary": "Метод не дозволено. HTTP метод не дозволено для запитуваного ресурсу.",
				"whenToUse1": "HTTP метод не підтримується для кінцевої точки",
				"whenToUse2": "Кінцева точка існує, але метод невірний",
				"causes1": "Метод не реалізовано для ресурсу",
				"causes2": "Дозволені лише певні методи",
				"checklist1": "Перевірте, що заголовок Allow перелічує дозволені методи",
				"checklist2": "Тестуйте з різними HTTP методами"
			},
			"408": {
				"summary": "Тайм-аут запиту. Сервер не дочекався запиту.",
				"whenToUse1": "Клієнт надто довго надсилав запит",
				"whenToUse2": "Тайм-аут запиту до завершення",
				"causes1": "Клієнт не надіслав запит вчасно",
				"causes2": "Тайм-аут мережевого з'єднання",
				"checklist1": "Перевірте конфігурацію тайм-ауту",
				"checklist2": "Тестуйте з повільними з'єднаннями"
			},
			"409": {
				"summary": "Конфлікт ресурсу. Запит конфліктує з поточним станом ресурсу.",
				"whenToUse1": "Дублювання створення ресурсу",
				"whenToUse2": "Конфлікт одночасного змінення",
				"whenToUse3": "Конфлікт стану (наприклад, видалення активного ресурсу)",
				"causes1": "Ресурс вже існує з таким самим ідентифікатором",
				"causes2": "Конфлікт оптимістичного блокування",
				"causes3": "Порушення бізнес-правил",
				"checklist1": "Перевірте, що помилка пояснює конфлікт",
				"checklist2": "Перевірте, чи потрібна логіка повторної спроби",
				"checklist3": "Тестуйте сценарії одночасного змінення"
			},
			"410": {
				"summary": "Видалено. Ресурс більше недоступний і не буде доступний знову.",
				"whenToUse1": "Ресурс постійно видалено",
				"whenToUse2": "Ресурс видалено і не повернеться",
				"causes1": "Ресурс постійно видалено",
				"causes2": "Ресурс застарів і видалено",
				"checklist1": "Перевірте, що ресурс не буде відновлено",
				"checklist2": "Перевірте, що повідомлення про помилку пояснює видалення"
			},
			"412": {
				"summary": "Умова не виконана. Одна або більше умов у полях заголовків запиту оцінено як хибні.",
				"whenToUse1": "Умова If-Match або If-None-Match не виконана",
				"whenToUse2": "Умова If-Unmodified-Since не виконана",
				"causes1": "Невідповідність ETag",
				"causes2": "Ресурс змінено з моменту останнього запиту",
				"checklist1": "Перевірте заголовки умов",
				"checklist2": "Тестуйте сценарії оптимістичного блокування"
			},
			"413": {
				"summary": "Тіло запиту занадто велике. Сущність запиту більша за межі, визначені сервером.",
				"whenToUse1": "Тіло запиту перевищує ліміт розміру",
				"whenToUse2": "Файл для завантаження занадто великий",
				"causes1": "Тіло запиту перевищує ліміт сервера",
				"causes2": "Розмір файлу занадто великий",
				"checklist1": "Перевірте, що ліміт розміру задокументовано",
				"checklist2": "Тестуйте з різними розмірами тіла запиту"
			},
			"415": {
				"summary": "Непідтримуваний тип медіа. Сущність запиту має тип медіа, який сервер не підтримує.",
				"whenToUse1": "Невірний заголовок Content-Type",
				"whenToUse2": "Сервер приймає лише певні типи медіа",
				"causes1": "Content-Type не підтримується (наприклад, XML замість JSON)",
				"causes2": "Відсутній або невірний заголовок Content-Type",
				"checklist1": "Перевірте, що заголовок Accept перевіряється",
				"checklist2": "Тестуйте з різними значеннями Content-Type"
			},
			"422": {
				"summary": "Необроблювана сущність. Запит правильно сформований, але семантично невалідний.",
				"whenToUse1": "Помилки валідації в тілі запиту",
				"whenToUse2": "Валідація бізнес-логіки не вдалася",
				"whenToUse3": "Семантичні помилки (наприклад, невалідний діапазон дат)",
				"causes1": "Валідація поля не вдалася",
				"causes2": "Порушення бізнес-правил",
				"causes3": "Невірні зв'язки даних",
				"checklist1": "Перевірте, що деталі помилки вказують конкретні поля",
				"checklist2": "Перевірте, що формат помилки включає помилки на рівні полів",
				"checklist3": "Тестуйте з різними сценаріями валідації",
				"checklist4": "Переконайтеся, що використовується 422, а не 400 для валідації"
			},
			"429": {
				"summary": "Занадто багато запитів. Користувач надіслав занадто багато запитів за певний час.",
				"whenToUse1": "Перевищено ліміт швидкості",
				"whenToUse2": "Занадто багато запитів з того самого IP/користувача",
				"causes1": "Перевищено поріг ліміту швидкості",
				"causes2": "Занадто часті виклики API",
				"causes3": "Спрацював захист від DDoS",
				"checklist1": "Перевірте, що заголовок Retry-After присутній",
				"checklist2": "Перевірте, що повідомлення про помилку включає інформацію про ліміт швидкості",
				"checklist3": "Тестуйте поведінку обмеження швидкості"
			},
			"500": {
				"summary": "Внутрішня помилка сервера. Сервер зіткнувся з неочікуваною умовою.",
				"whenToUse1": "Неочікувана помилка сервера",
				"whenToUse2": "Необроблений виняток",
				"causes1": "Помилка коду додатку",
				"causes2": "Збій підключення до бази даних",
				"causes3": "Збій стороннього сервісу",
				"causes4": "Помилка конфігурації",
				"checklist1": "Перевірте, що помилка не розкриває чутливу інформацію",
				"checklist2": "Перевірте, що requestId включено для налагодження",
				"checklist3": "Переконайтеся у правильному логуванні помилок"
			},
			"501": {
				"summary": "Не реалізовано. Сервер не підтримує функціональність, необхідну для виконання запиту.",
				"whenToUse1": "Функція ще не реалізована",
				"whenToUse2": "Метод не підтримується сервером",
				"causes1": "Кінцева точка або функція недоступна",
				"checklist1": "Перевірте, що функція дійсно не реалізована",
				"checklist2": "Перевірте, чи 404 більш доречний"
			},
			"502": {
				"summary": "Поганий шлюз. Сервер, що діє як шлюз, отримав невалідну відповідь.",
				"whenToUse1": "Невалідна відповідь від upstream сервера",
				"whenToUse2": "Помилка upstream сервера",
				"causes1": "Upstream сервер повернув невалідну відповідь",
				"causes2": "Проблема конфігурації проксі/шлюзу",
				"causes3": "Мережева проблема між серверами",
				"checklist1": "Перевірте, що повідомлення про помилку зрозуміле",
				"checklist2": "Перевірте, чи доречна повторна спроба",
				"checklist3": "Тестуйте збої upstream сервера"
			},
			"503": {
				"summary": "Сервіс недоступний. Сервер тимчасово не може обробити запит.",
				"whenToUse1": "Сервіс тимчасово недоступний для обслуговування",
				"whenToUse2": "Сервер перевантажений",
				"whenToUse3": "Тимчасова недоступність",
				"causes1": "Заплановане обслуговування",
				"causes2": "Перевантаження сервера",
				"causes3": "Залежний сервіс недоступний",
				"checklist1": "Перевірте заголовок Retry-After, якщо застосовно",
				"checklist2": "Перевірте, що повідомлення про помилку пояснює недоступність",
				"checklist3": "Тестуйте сценарії відновлення сервісу"
			},
			"504": {
				"summary": "Тайм-аут шлюзу. Сервер, що діє як шлюз, не отримав своєчасну відповідь.",
				"whenToUse1": "Тайм-аут upstream сервера",
				"whenToUse2": "Запит зайняв занадто багато часу для обробки",
				"causes1": "Upstream сервер не відповів вчасно",
				"causes2": "Мережевий тайм-аут",
				"causes3": "Повільна обробка upstream",
				"checklist1": "Перевірте конфігурацію тайм-ауту",
				"checklist2": "Перевірте, чи можна оптимізувати запит",
				"checklist3": "Тестуйте сценарії тайм-ауту"
			}
		}
	},
	"userAgentParser": {
		"title": "Парсер User-Agent - QA Toolbox",
		"description": "Розпарсуйте рядки User-Agent для витягування інформації про браузер, ОС, пристрій та версію локально."
	},
	"privacy": {
		"title": "Конфіденційність - QA Toolbox",
		"description": "Політика конфіденційності для QA Toolbox. Ми не збираємо, не зберігаємо та не передаємо жодних даних."
	}
}
