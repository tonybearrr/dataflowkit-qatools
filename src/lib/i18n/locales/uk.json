{
	"common": {
		"qaToolbox": "QA Toolbox",
		"madeBy": "Створено Антоном",
		"donate": "Підтримати",
		"privacy": "Політика конфіденційності",
		"about": "Про проєкт",
		"privacyFirst": "Працює локально у вашому браузері. Без відстеження. Без облікових записів.",
		"noTracking": "Без відстеження",
		"localOnly": "Тільки локально",
		"builtBy": "Частина",
		"moreToolsComing": "Більше інструментів незабаром...",
		"copy": "Копіювати",
		"clear": "Очистити",
		"parse": "Розпарсити"
	},
	"nav": {
		"testDataGenerator": "Тестові дані",
		"apiResponseValidator": "Валідатор API",
		"statusCodeReference": "Статус-коди",
		"userAgentParser": "User Agent",
		"headersInspector": "Headers"
	},
	"home": {
		"title": "QA Toolbox",
		"description": "Швидкі інструменти для QA-тестування з пріоритетом конфіденційності. Без бекенду. Без відстеження. Все працює локально у вашому браузері.",
		"testDataGenerator": {
			"title": "Генератор тестових даних",
			"description": "Генеруйте тестові дані: email, номери телефонів, UUID, імена, адреси та інше.",
			"tags": ["Email", "Телефон", "UUID"]
		},
		"apiResponseValidator": {
			"title": "Валідатор відповідей API",
			"description": "Валідуйте JSON-відповіді за схемою. Перевіряйте структуру, типи та обов'язкові поля.",
			"tags": ["JSON Schema", "Валідація", "API"]
		},
		"statusCodeReference": {
			"title": "Довідник статус-кодів",
			"description": "Швидкий довідник HTTP статус-кодів з описом та прикладами використання.",
			"tags": ["HTTP", "Статус", "Довідник"]
		},
		"userAgentParser": {
			"title": "Парсер User-Agent",
			"description": "Розпарсуйте рядки User-Agent для витягування інформації про браузер, ОС, пристрій та версію.",
			"tags": ["Браузер", "ОС", "Пристрій"]
		},
		"headersInspector": {
			"title": "Інспектор заголовків",
			"description": "Парсинг та аналіз HTTP заголовків. Зрозумійте їх призначення та виявіть проблеми конфігурації.",
			"tags": ["HTTP", "Заголовки", "CORS"]
		}
	},
	"testDataGenerator": {
		"title": "Генератор тестових даних - QA Toolbox",
		"description": "Генеруйте тестові дані локально: email, номери телефонів, UUID, імена, адреси та інше. Дані не відправляються на сервери.",
		"heading": "Генератор тестових даних",
		"subtitle": "Test Data Generator — інструмент для генерації тестових даних без бекенду. Дозволяє задати схему даних, переглянути результат і експортувати його у JSON або CSV для тестування, API та розробки.",
		"whatIsTestData": "Що таке генерація тестових даних?",
		"testDataDescription": "Генерація тестових даних — це процес створення реалістичних, структурованих даних для тестування. Цей інструмент дозволяє визначити схему з різними типами полів (рядки, числа, дати, email тощо) та генерувати кілька рядків даних, які відповідають вашим вимогам.",
		"parameters": "Параметри",
		"presets": "Пресети",
		"presetsDescription": "Готові шаблони схем:",
		"presetsList": "User, Order, Address, Event",
		"fields": "Поля",
		"fieldName": "Назва поля — ключ у фінальному результаті",
		"fieldType": "Тип — тип даних (uuid, email, name, phone, address, date, string)",
		"fieldRequired": "Обовʼязкове — поле завжди присутнє",
		"fieldManage": "Порядок / Дублювання / Видалення — керування структурою",
		"preview": "Попередній перегляд",
		"previewDescription": "Таблиця згенерованих даних",
		"previewRegenerate": "Regenerate — створити нові дані з тією ж схемою",
		"export": "Експорт",
		"exportRows": "Rows — кількість рядків",
		"exportSeed": "Seed — фіксоване значення для повторюваних результатів",
		"exportFormat": "Формат — JSON або CSV",
		"exportArrayKey": "Array key (необовʼязково) — обгортає масив в обʼєкт",
		"exportActions": "Copy / Download — копіювання або завантаження",
		"features": "Можливості",
		"featureSchema": "Визначення користувацьких схем з різними типами полів",
		"featureSeed": "Використання seed для відтворюваних, детермінованих даних",
		"featureExport": "Експорт у формати JSON або CSV",
		"featureLocal": "Вся обробка відбувається локально у вашому браузері",
		"useCases": "Сценарії використання",
		"useCase1": "Створення тестових наборів даних для тестування API",
		"useCase2": "Генерація зразкових даних для заповнення бази даних",
		"useCase3": "Створення мок-даних для фронтенд розробки",
		"useCase4": "Створення тестових фікстур для автоматизованого тестування",
		"privacy": "Приватність",
		"privacyText": "Усі дані генеруються локально у браузері. Дані не передаються на сервер.",
		"confirmReplaceTitle": "Замінити схему?",
		"confirmReplaceMessage": "Це замінить вашу поточну схему. Продовжити?",
		"confirmCancel": "Скасувати",
		"confirmContinue": "Продовжити"
	},
	"payloadBuilder": {
		"title": "Payload Builder - QA Toolbox",
		"description": "Створюйте та ламайте JSON payload для тестування API. Генеруйте невалідні варіанти для тестування валідації.",
		"heading": "Payload Builder + Breaker",
		"subtitle": "Створюйте JSON payload візуально або в коді. Генеруйте невалідні варіанти для тестування валідації API.",
		"whatIsPayloadBuilder": "Що таке Payload Builder + Breaker?",
		"payloadBuilderDescription": "Payload Builder + Breaker — це локальний інструмент для створення та навмисного ламання JSON payload'ів для тестування API. Створюйте валідні payload'и візуально або в JSON і генеруйте невалідні варіанти для перевірки валідації та обробки помилок. Усі операції виконуються локально у вашому браузері.",
		"parameters": "Параметри",
		"templates": "Шаблони",
		"templatesDescription": "Готові payload'и для типових API-запитів",
		"templatesList": "",
		"jsonEditor": "JSON Editor",
		"jsonEditorDescription": "Редагування, форматування та мінімізація JSON з валідацією",
		"treeBuilder": "Tree Builder",
		"treeBuilderDescription": "Візуальне створення JSON-структур",
		"breaker": "Варіанти (Breaker)",
		"breakerDescription": "Генерація помилкових payload'ів (відсутні поля, неправильні типи, null, edge cases)",
		"breakerPresets": "",
		"breakerPresetsList": "",
		"output": "Output",
		"outputDescription": "Перегляд, порівняння, копіювання або експорт payload'ів",
		"privacy": "Приватність",
		"privacyText": "Усі дані обробляються локально у вашому браузері. Дані не відправляються на сервер."
	},
	"apiResponseValidator": {
		"title": "Валідатор відповідей API - QA Toolbox",
		"description": "API Validator — це інструмент для розробників і QA-інженерів, який дозволяє перевіряти відповідність JSON-payload очікуваному контракту, описаному за допомогою JSON Schema. Він підсвічує помилки валідації, проблеми зі схемою та форматуванням, допомагаючи виявити помилки ще до відправки запиту на бекенд. Уся перевірка виконується локально у браузері — швидко та без передачі даних на сервер.",
		"heading": "API Validator",
		"subtitle": "API Validator допомагає перевіряти JSON-payload запитів відповідно до JSON Schema прямо у вашому браузері. Швидко виявляйте невідповідності схемі, некоректні типи даних і відсутні обовʼязкові поля під час розробки API та QA-тестування.",
		"payloadLabel": "Payload JSON",
		"outputLabel": "Output",
		"schemaLabel": "Schema JSON",
		"validate": "Валідувати",
		"autoValidate": "Авто-валідація",
		"formatPayload": "Форматувати Payload",
		"formatSchema": "Форматувати Schema",
		"selectPreset": "Sample Schema",
		"reset": "Скинути",
		"valid": "Валідний",
		"invalid": "Невалідний",
		"parseError": "Помилка парсингу",
		"schemaParseError": "Помилка парсингу Schema",
		"line": "Рядок",
		"column": "Колонка",
		"error": "помилка",
		"errors": "помилок",
		"keyword": "Ключове слово",
		"expected": "Очікувалось",
		"received": "Отримано",
		"copy": "Копіювати",
		"copied": "Скопійовано!",
		"copyError": "Копіювати помилку",
		"noValidation": "Натисніть Валідувати для перевірки JSON за схемою",
		"formattedOutput": "Відформатований вивід",
		"whatIs": "Що таке API Validator?",
		"parameters": "Параметри",
		"payloadDesc": "JSON payload для валідації",
		"schemaDesc": "JSON Schema (draft 2020-12 або draft-07)",
		"autoValidateDesc": "Автоматично валідувати при зміні вводу",
		"presets": "Presets",
		"presetsDesc": "Готові схеми та payload'и для типових API-запитів",
		"format": "Форматування",
		"formatDesc": "Форматувати JSON з правильними відступами",
		"privacy": "Приватність",
		"privacyText": "Уся валідація відбувається локально у вашому браузері. Дані не відправляються на сервер.",
		"useCases": "Сценарії використання",
		"useCasesSubtitle": "Використовуйте API Validator для:",
		"useCase1": "перевірки JSON запитів перед відправкою на бекенд",
		"useCase2": "тестування серверної валідації під час QA",
		"useCase3": "пошуку помилок у схемі або payload-i",
		"useCase4": "перевірки обов'язкових полів, типів та форматів даних",
		"whyUse": "Навіщо використовувати цей інструмент?",
		"whyUse1": "Миттєвий фідбек для АРІ payload-ів",
		"whyUse2": "Підтримка JSON Schema (draft-07, draft-2020-12)",
		"whyUse3": "Підходить для розробників і QA інженерів",
		"typicalWorkflow": "Типовий флоу",
		"workflow1": "Вставте або введіть JSON payload",
		"workflow2": "Додайте або оберіть JSON Schema",
		"workflow3": "Натисніть Validate або увімкніть авто-валідацію",
		"workflow4": "Перегляньте помилки або підтвердження валідності",
		"workflow5": "За потреби скопіюйте відформатований результат"
	},
	"statusCodeReference": {
		"title": "HTTP Status Codes Explorer - QA Toolbox",
		"description": "Швидкий локальний довідник HTTP статус-кодів з описом, прикладами використання та шаблонами API відповідей.",
		"heading": "HTTP Status Codes Explorer",
		"subtitle": "Швидкий довідник HTTP статус-кодів з описом, прикладами використання та рекомендованими API відповідями.",
		"searchPlaceholder": "Пошук за кодом або ключовим словом...",
		"categoryAll": "Всі",
		"category1xx": "1xx",
		"category2xx": "2xx",
		"category3xx": "3xx",
		"category4xx": "4xx",
		"category5xx": "5xx",
		"commonOnly": "Тільки поширені",
		"categoryLabel": {
			"informational": "Інформаційні",
			"success": "Успіх",
			"redirection": "Перенаправлення",
			"clientError": "Помилка клієнта",
			"serverError": "Помилка сервера"
		},
		"whenToUse": "Коли використовувати",
		"commonCauses": "Типові причини",
		"whatToReturn": "Що повертати",
		"testingChecklist": "Чек-лист для тестування",
		"relatedCodes": "Пов'язані коди",
		"copyJson": "Копіювати JSON",
		"copyTitle": "Копіювати заголовок",
		"copied": "Скопійовано!",
		"noResults": "Нічого не знайдено",
		"noResultsSuggestion": "Спробуйте пошук: 404, not found, rate limit, unauthorized",
		"whatIs": "Що таке HTTP Status Codes Explorer?",
		"whatIsDescription": "HTTP Status Codes Explorer — це локальний інструмент для швидкого розуміння HTTP статус-кодів, їх типових причин та рекомендованих API відповідей. Допомагає QA інженерам, розробникам та бекенд інженерам приймати обґрунтовані рішення щодо вибору статус-кодів та структури відповідей про помилки.",
		"qaUsage": "Як QA використовує статус-коди в тестуванні API",
		"qaUsageDescription": "QA інженери використовують статус-коди для перевірки поведінки API, тестування обробки помилок та забезпечення правильних форматів відповідей. Цей інструмент допомагає визначити правильний статус-код для різних сценаріїв та надає приклади відповідей для тестування.",
		"commonMistakes": "Типові помилки: 401 vs 403, 409 vs 422, 502 vs 504",
		"commonMistakesDescription": "401 (Unauthorized) означає, що аутентифікація відсутня або невалідна, тоді як 403 (Forbidden) означає, що користувач аутентифікований, але не має дозволу. 409 (Conflict) вказує на конфлікт стану, тоді як 422 (Unprocessable Entity) означає, що запит правильно сформований, але семантично невалідний. 502 (Bad Gateway) — це помилка upstream сервера, тоді як 504 (Gateway Timeout) означає, що upstream сервер не відповів вчасно.",
		"statusCodes": {
			"100": {
				"summary": "Продовжити. Сервер отримав заголовки запиту, і клієнт повинен продовжити надсилання тіла запиту.",
				"whenToUse1": "Заголовок Expect вказує, що клієнт надішле тіло",
				"whenToUse2": "Велике завантаження тіла запиту",
				"causes1": "Клієнт надіслав заголовок Expect: 100-continue",
				"causes2": "Сервер готовий отримати тіло запиту",
				"checklist1": "Перевірте, що клієнт обробляє відповідь 100",
				"checklist2": "Перевірте, що тіло запиту надсилається після 100"
			},
			"101": {
				"summary": "Перемикання протоколів. Сервер перемикає протоколи за запитом клієнта.",
				"whenToUse1": "Оновлення до WebSocket",
				"whenToUse2": "Запит на оновлення протоколу",
				"causes1": "Клієнт запросив оновлення протоколу",
				"checklist1": "Перевірте, що оновлення протоколу успішне"
			},
			"200": {
				"summary": "Запит успішний. Стандартна відповідь для успішних HTTP запитів.",
				"whenToUse1": "Успішні GET, PUT або PATCH запити",
				"whenToUse2": "Повернення даних у тілі відповіді",
				"whenToUse3": "Стандартна успішна відповідь",
				"causes1": "Нормальна успішна обробка запиту",
				"causes2": "Ресурс успішно отримано або оновлено",
				"checklist1": "Перевірте, що тіло відповіді містить очікувані дані",
				"checklist2": "Перевірте, що заголовок Content-Type відповідає формату відповіді",
				"checklist3": "Переконайтеся, що відповідь правильно відформатована"
			},
			"201": {
				"summary": "Ресурс успішно створено. Зазвичай використовується після POST запитів, які створюють нові ресурси.",
				"whenToUse1": "Після успішного POST запиту, що створює новий ресурс",
				"whenToUse2": "Коли повертається створений ресурс у тілі відповіді",
				"causes1": "Новий ресурс успішно створено",
				"causes2": "Створення ресурсу з заголовком Location",
				"checklist1": "Перевірте, що заголовок Location вказує на новий ресурс",
				"checklist2": "Перевірте, що тіло відповіді містить створений ресурс",
				"checklist3": "Переконайтеся, що ID ресурсу включено"
			},
			"204": {
				"summary": "Запит успішний, але немає вмісту для повернення. Використовується для успішних операцій, які не потребують тіла відповіді.",
				"whenToUse1": "Успішні DELETE запити",
				"whenToUse2": "Успішні PUT/PATCH без необхідності відповіді",
				"causes1": "Операція успішно завершена без вмісту",
				"checklist1": "Перевірте, що тіло відповіді порожнє",
				"checklist2": "Перевірте, що операція дійсно успішна"
			},
			"202": {
				"summary": "Прийнято. Запит прийнято для обробки, але обробка ще не завершена.",
				"whenToUse1": "Асинхронна обробка запиту",
				"whenToUse2": "Запит поставлено в чергу для фонової обробки",
				"causes1": "Запит прийнято, але ще не оброблено",
				"checklist1": "Перевірте, що запит дійсно обробляється",
				"checklist2": "Перевірте, чи надано кінцеву точку статусу"
			},
			"301": {
				"summary": "Переміщено назавжди. Ресурс було постійно переміщено на нову адресу.",
				"whenToUse1": "Ресурс постійно переміщено на новий URL",
				"whenToUse2": "Структура URL змінена назавжди",
				"causes1": "Місце розташування ресурсу змінено",
				"causes2": "Реструктуризація домену або шляху",
				"checklist1": "Перевірте, що заголовок Location вказує на новий URL",
				"checklist2": "Перевірте, що перенаправлення постійне"
			},
			"302": {
				"summary": "Знайдено (тимчасове перенаправлення). Ресурс тимчасово розташований за іншою адресою.",
				"whenToUse1": "Тимчасове переміщення ресурсу",
				"whenToUse2": "Тимчасова зміна URL",
				"causes1": "Ресурс тимчасово переміщено",
				"causes2": "Обслуговування або балансування навантаження",
				"checklist1": "Перевірте, що заголовок Location присутній",
				"checklist2": "Перевірте метод перенаправлення (GET vs POST)"
			},
			"304": {
				"summary": "Не змінено. Ресурс не змінювався з моменту останнього запиту.",
				"whenToUse1": "Умовний GET з If-None-Match або If-Modified-Since",
				"whenToUse2": "Кешований ресурс все ще валідний",
				"causes1": "Ресурс не змінювався з моменту останнього запиту",
				"checklist1": "Перевірте заголовки ETag або Last-Modified",
				"checklist2": "Перевірте, що тіло відповіді порожнє"
			},
			"307": {
				"summary": "Тимчасове перенаправлення. Запит повинен бути повторений з тим самим HTTP методом.",
				"whenToUse1": "Тимчасове перенаправлення зі збереженням методу",
				"whenToUse2": "Балансування навантаження або обслуговування",
				"causes1": "Тимчасове переміщення сервера",
				"checklist1": "Перевірте, що HTTP метод збережено",
				"checklist2": "Перевірте заголовок Location"
			},
			"308": {
				"summary": "Постійне перенаправлення. Запит і всі майбутні запити повинні бути повторені з використанням наданого URI.",
				"whenToUse1": "Постійне перенаправлення зі збереженням методу",
				"whenToUse2": "Постійна зміна URL",
				"causes1": "Постійне переміщення ресурсу",
				"checklist1": "Перевірте, що метод і тіло збережено",
				"checklist2": "Перевірте, що перенаправлення дійсно постійне"
			},
			"400": {
				"summary": "Невірний синтаксис запиту або параметри. Сервер не може обробити запит через помилку клієнта.",
				"whenToUse1": "Невірний синтаксис запиту",
				"whenToUse2": "Невірні параметри запиту",
				"whenToUse3": "Відсутні обов'язкові поля",
				"causes1": "Невірний синтаксис JSON",
				"causes2": "Відсутні обов'язкові параметри",
				"causes3": "Невірні типи параметрів",
				"causes4": "Невірно сформоване тіло запиту",
				"checklist1": "Перевірте, що повідомлення про помилку пояснює проблему",
				"checklist2": "Перевірте, що відповідь про помилку включає requestId",
				"checklist3": "Переконайтеся, що формат помилки узгоджений",
				"checklist4": "Тестуйте з різними невалідними входами"
			},
			"401": {
				"summary": "Потрібна аутентифікація або вона не вдалася. Клієнт повинен аутентифікуватися для отримання запитуваної відповіді.",
				"whenToUse1": "Відсутній або невалідний токен аутентифікації",
				"whenToUse2": "Термін дії облікових даних аутентифікації закінчився",
				"whenToUse3": "Схема аутентифікації не підтримується",
				"causes1": "Заголовок Authorization не надано",
				"causes2": "Невалідний або застарілий токен",
				"causes3": "Облікові дані аутентифікації невірні",
				"checklist1": "Перевірте, що заголовок WWW-Authenticate присутній",
				"checklist2": "Перевірте, що повідомлення про помилку не розкриває чутливу інформацію",
				"checklist3": "Тестуйте з відсутніми, невалідними та застарілими токенами",
				"checklist4": "Переконайтеся, що використовується 401, а не 403 для проблем з аутентифікацією"
			},
			"403": {
				"summary": "Доступ заборонено. Клієнт не має дозволу на доступ до ресурсу.",
				"whenToUse1": "Користувач аутентифікований, але не має дозволу",
				"whenToUse2": "Ресурс існує, але доступ заборонено",
				"whenToUse3": "Недостатньо привілеїв для операції",
				"causes1": "Користувач не має необхідних дозволів",
				"causes2": "Доступ до ресурсу обмежено політикою",
				"causes3": "Операція не дозволена для ролі користувача",
				"checklist1": "Перевірте, що користувач аутентифікований (не 401)",
				"checklist2": "Перевірте, що повідомлення про помилку пояснює проблему з дозволами",
				"checklist3": "Тестуйте з різними ролями користувачів"
			},
			"404": {
				"summary": "Ресурс не знайдено. Сервер не може знайти запитуваний ресурс.",
				"whenToUse1": "Ресурс не існує",
				"whenToUse2": "Невірний ID ресурсу або шлях",
				"whenToUse3": "Кінцева точка не існує",
				"causes1": "Ресурс було видалено",
				"causes2": "Невірний URL або ID ресурсу",
				"causes3": "Ресурс ніколи не існував",
				"causes4": "Помилка в шляху запиту",
				"checklist1": "Перевірте, що повідомлення про помилку зрозуміле",
				"checklist2": "Перевірте, що відповідь не розкриває внутрішню структуру",
				"checklist3": "Тестуйте з різними невалідними ID"
			},
			"405": {
				"summary": "Метод не дозволено. HTTP метод не дозволено для запитуваного ресурсу.",
				"whenToUse1": "HTTP метод не підтримується для кінцевої точки",
				"whenToUse2": "Кінцева точка існує, але метод невірний",
				"causes1": "Метод не реалізовано для ресурсу",
				"causes2": "Дозволені лише певні методи",
				"checklist1": "Перевірте, що заголовок Allow перелічує дозволені методи",
				"checklist2": "Тестуйте з різними HTTP методами"
			},
			"408": {
				"summary": "Тайм-аут запиту. Сервер не дочекався запиту.",
				"whenToUse1": "Клієнт надто довго надсилав запит",
				"whenToUse2": "Тайм-аут запиту до завершення",
				"causes1": "Клієнт не надіслав запит вчасно",
				"causes2": "Тайм-аут мережевого з'єднання",
				"checklist1": "Перевірте конфігурацію тайм-ауту",
				"checklist2": "Тестуйте з повільними з'єднаннями"
			},
			"409": {
				"summary": "Конфлікт ресурсу. Запит конфліктує з поточним станом ресурсу.",
				"whenToUse1": "Дублювання створення ресурсу",
				"whenToUse2": "Конфлікт одночасного змінення",
				"whenToUse3": "Конфлікт стану (наприклад, видалення активного ресурсу)",
				"causes1": "Ресурс вже існує з таким самим ідентифікатором",
				"causes2": "Конфлікт оптимістичного блокування",
				"causes3": "Порушення бізнес-правил",
				"checklist1": "Перевірте, що помилка пояснює конфлікт",
				"checklist2": "Перевірте, чи потрібна логіка повторної спроби",
				"checklist3": "Тестуйте сценарії одночасного змінення"
			},
			"410": {
				"summary": "Видалено. Ресурс більше недоступний і не буде доступний знову.",
				"whenToUse1": "Ресурс постійно видалено",
				"whenToUse2": "Ресурс видалено і не повернеться",
				"causes1": "Ресурс постійно видалено",
				"causes2": "Ресурс застарів і видалено",
				"checklist1": "Перевірте, що ресурс не буде відновлено",
				"checklist2": "Перевірте, що повідомлення про помилку пояснює видалення"
			},
			"412": {
				"summary": "Умова не виконана. Одна або більше умов у полях заголовків запиту оцінено як хибні.",
				"whenToUse1": "Умова If-Match або If-None-Match не виконана",
				"whenToUse2": "Умова If-Unmodified-Since не виконана",
				"causes1": "Невідповідність ETag",
				"causes2": "Ресурс змінено з моменту останнього запиту",
				"checklist1": "Перевірте заголовки умов",
				"checklist2": "Тестуйте сценарії оптимістичного блокування"
			},
			"413": {
				"summary": "Тіло запиту занадто велике. Сущність запиту більша за межі, визначені сервером.",
				"whenToUse1": "Тіло запиту перевищує ліміт розміру",
				"whenToUse2": "Файл для завантаження занадто великий",
				"causes1": "Тіло запиту перевищує ліміт сервера",
				"causes2": "Розмір файлу занадто великий",
				"checklist1": "Перевірте, що ліміт розміру задокументовано",
				"checklist2": "Тестуйте з різними розмірами тіла запиту"
			},
			"415": {
				"summary": "Непідтримуваний тип медіа. Сущність запиту має тип медіа, який сервер не підтримує.",
				"whenToUse1": "Невірний заголовок Content-Type",
				"whenToUse2": "Сервер приймає лише певні типи медіа",
				"causes1": "Content-Type не підтримується (наприклад, XML замість JSON)",
				"causes2": "Відсутній або невірний заголовок Content-Type",
				"checklist1": "Перевірте, що заголовок Accept перевіряється",
				"checklist2": "Тестуйте з різними значеннями Content-Type"
			},
			"422": {
				"summary": "Необроблювана сущність. Запит правильно сформований, але семантично невалідний.",
				"whenToUse1": "Помилки валідації в тілі запиту",
				"whenToUse2": "Валідація бізнес-логіки не вдалася",
				"whenToUse3": "Семантичні помилки (наприклад, невалідний діапазон дат)",
				"causes1": "Валідація поля не вдалася",
				"causes2": "Порушення бізнес-правил",
				"causes3": "Невірні зв'язки даних",
				"checklist1": "Перевірте, що деталі помилки вказують конкретні поля",
				"checklist2": "Перевірте, що формат помилки включає помилки на рівні полів",
				"checklist3": "Тестуйте з різними сценаріями валідації",
				"checklist4": "Переконайтеся, що використовується 422, а не 400 для валідації"
			},
			"429": {
				"summary": "Занадто багато запитів. Користувач надіслав занадто багато запитів за певний час.",
				"whenToUse1": "Перевищено ліміт швидкості",
				"whenToUse2": "Занадто багато запитів з того самого IP/користувача",
				"causes1": "Перевищено поріг ліміту швидкості",
				"causes2": "Занадто часті виклики API",
				"causes3": "Спрацював захист від DDoS",
				"checklist1": "Перевірте, що заголовок Retry-After присутній",
				"checklist2": "Перевірте, що повідомлення про помилку включає інформацію про ліміт швидкості",
				"checklist3": "Тестуйте поведінку обмеження швидкості"
			},
			"500": {
				"summary": "Внутрішня помилка сервера. Сервер зіткнувся з неочікуваною умовою.",
				"whenToUse1": "Неочікувана помилка сервера",
				"whenToUse2": "Необроблений виняток",
				"causes1": "Помилка коду додатку",
				"causes2": "Збій підключення до бази даних",
				"causes3": "Збій стороннього сервісу",
				"causes4": "Помилка конфігурації",
				"checklist1": "Перевірте, що помилка не розкриває чутливу інформацію",
				"checklist2": "Перевірте, що requestId включено для налагодження",
				"checklist3": "Переконайтеся у правильному логуванні помилок"
			},
			"501": {
				"summary": "Не реалізовано. Сервер не підтримує функціональність, необхідну для виконання запиту.",
				"whenToUse1": "Функція ще не реалізована",
				"whenToUse2": "Метод не підтримується сервером",
				"causes1": "Кінцева точка або функція недоступна",
				"checklist1": "Перевірте, що функція дійсно не реалізована",
				"checklist2": "Перевірте, чи 404 більш доречний"
			},
			"502": {
				"summary": "Поганий шлюз. Сервер, що діє як шлюз, отримав невалідну відповідь.",
				"whenToUse1": "Невалідна відповідь від upstream сервера",
				"whenToUse2": "Помилка upstream сервера",
				"causes1": "Upstream сервер повернув невалідну відповідь",
				"causes2": "Проблема конфігурації проксі/шлюзу",
				"causes3": "Мережева проблема між серверами",
				"checklist1": "Перевірте, що повідомлення про помилку зрозуміле",
				"checklist2": "Перевірте, чи доречна повторна спроба",
				"checklist3": "Тестуйте збої upstream сервера"
			},
			"503": {
				"summary": "Сервіс недоступний. Сервер тимчасово не може обробити запит.",
				"whenToUse1": "Сервіс тимчасово недоступний для обслуговування",
				"whenToUse2": "Сервер перевантажений",
				"whenToUse3": "Тимчасова недоступність",
				"causes1": "Заплановане обслуговування",
				"causes2": "Перевантаження сервера",
				"causes3": "Залежний сервіс недоступний",
				"checklist1": "Перевірте заголовок Retry-After, якщо застосовно",
				"checklist2": "Перевірте, що повідомлення про помилку пояснює недоступність",
				"checklist3": "Тестуйте сценарії відновлення сервісу"
			},
			"504": {
				"summary": "Тайм-аут шлюзу. Сервер, що діє як шлюз, не отримав своєчасну відповідь.",
				"whenToUse1": "Тайм-аут upstream сервера",
				"whenToUse2": "Запит зайняв занадто багато часу для обробки",
				"causes1": "Upstream сервер не відповів вчасно",
				"causes2": "Мережевий тайм-аут",
				"causes3": "Повільна обробка upstream",
				"checklist1": "Перевірте конфігурацію тайм-ауту",
				"checklist2": "Перевірте, чи можна оптимізувати запит",
				"checklist3": "Тестуйте сценарії тайм-ауту"
			}
		}
	},
	"userAgentParser": {
		"title": "Парсер User-Agent - QA Toolbox",
		"description": "Розпарсуйте рядки User-Agent для витягування інформації про браузер, ОС, пристрій та версію локально."
	},
	"headersInspector": {
		"title": "Інспектор заголовків - QA Toolbox",
		"description": "Парсинг та аналіз HTTP заголовків. Зрозумійте призначення кожного заголовка, виявіть типові проблеми та отримайте швидкі дії копіювання.",
		"heading": "Інспектор заголовків",
		"subtitle": "Парсинг HTTP заголовків, розуміння їх призначення та виявлення типових проблем конфігурації.",
		"inputLabel": "Заголовки",
		"placeholder": "Вставте заголовки з DevTools або виводу curl...\n\nПриклад:\nContent-Type: application/json\nAuthorization: Bearer token123",
		"typeLabel": "Тип:",
		"typeRequest": "Запит",
		"typeResponse": "Відповідь",
		"autoParse": "Авто-парсинг",
		"parse": "Парсити",
		"reset": "Скинути",
		"example": "Приклад",
		"exampleRequest": "Заголовки запиту",
		"exampleResponse": "Заголовки відповіді",
		"exampleCors": "Приклад помилки CORS",
		"exampleCookie": "Приклад проблеми з cookie",
		"headersList": "Заголовки",
		"noHeaders": "Вставте заголовки вище та натисніть Парсити, щоб почати.",
		"details": {
			"whatItDoes": "Що робить",
			"whenToUse": "Коли використовувати",
			"commonMistakes": "Типові помилки",
			"securityNotes": "Примітки безпеки",
			"quickActions": "Швидкі дії",
			"copyName": "Копіювати назву",
			"copyValue": "Копіювати значення",
			"copyFull": "Копіювати заголовок:значення",
			"selectHeader": "Виберіть заголовок для перегляду деталей",
			"noInfo": "Інформація для цього заголовка недоступна.",
			"duplicates": "дублікатів",
			"recommendation": "Рекомендація:",
			"hints": {
				"cacheValidationMissing": "Рекомендується додати ETag або Last-Modified для валідації кешу.",
				"sameSiteNoneSecure": "Додайте прапорець Secure при використанні SameSite=None.",
				"cannotUseStarWithCredentials": "Не можна використовувати \"*\" з credentials. Використовуйте конкретний origin замість цього.",
				"requiresSpecificAcao": "Потрібен конкретний Access-Control-Allow-Origin (не \"*\")."
			}
		},
		"issues": {
			"detectedIssues": "Виявлені проблеми",
			"showDetectedIssues": "Показати виявлені проблеми",
			"errors": "помилок",
			"warnings": "попереджень",
			"info": "інфо",
			"showOnlyErrors": "Показати тільки помилки",
			"hideIssues": "Приховати проблеми",
			"less": "Менше",
			"more": "Більше",
			"corsStarWithCredentials": "Невірна CORS: ACAO=\"*\" з ACAC=\"true\"",
			"corsStarWithCredentialsWhy": "Специфікація CORS не дозволяє wildcard origin з credentials. Використовуйте конкретний origin.",
			"corsVaryOrigin": "Рекомендується Vary: Origin при використанні конкретного ACAO з credentials",
			"corsVaryOriginWhy": "При використанні конкретного origin з credentials, додайте Vary: Origin для правильного кешування.",
			"corsMissingAcao": "Виявлено CORS запит, але немає заголовка ACAO у відповіді",
			"corsMissingAcaoWhy": "Запит містить заголовок Origin, але відповідь не вказує дозволені origins.",
			"cacheNoStoreWithEtag": "Cache-Control: no-store з ETag може бути зайвим",
			"cacheNoStoreWithEtagWhy": "no-store запобігає кешуванню, тому валідація ETag не потрібна.",
			"cacheMissingForApi": "Відповідь API (JSON) без заголовка Cache-Control",
			"cacheMissingForApiWhy": "Відповіді API повинні явно вказувати поведінку кешування.",
			"securityMissingHsts": "Виявлено HTTPS, але відсутній заголовок HSTS",
			"securityMissingHstsWhy": "HSTS допомагає запобігти атакам зниження протоколу.",
			"securityMissingXContentType": "HTML контент без заголовка X-Content-Type-Options",
			"securityMissingXContentTypeWhy": "Запобігає атакам MIME type sniffing.",
			"cookieSameSiteNoneNoSecure": "Set-Cookie: SameSite=None вимагає прапорець Secure",
			"cookieSameSiteNoneNoSecureWhy": "Cookie з SameSite=None повинні бути позначені Secure для запобігання перехоплення.",
			"cookieMissingHttpOnly": "Cookie типу сесії без прапорця HttpOnly",
			"cookieMissingHttpOnlyWhy": "HttpOnly запобігає доступу JavaScript, зменшуючи поверхню атаки XSS."
		},
		"headers": {
			"authorization": {
				"description": "Містить облікові дані для автентифікації клієнта на сервері.",
				"whenToUse1": "Bearer токени для автентифікації API",
				"whenToUse2": "Облікові дані Basic автентифікації",
				"mistakes1": "Відправка токенів у параметрах запиту замість заголовка",
				"mistakes2": "Не використання HTTPS для чутливих облікових даних",
				"security": "Завжди використовуйте HTTPS при відправці облікових даних. Розгляньте термін дії та ротацію токенів."
			},
			"wwwAuthenticate": {
				"description": "Вказує схему автентифікації, необхідну для доступу.",
				"whenToUse1": "Відповіді 401 Unauthorized для вказівки необхідної автентифікації",
				"mistakes1": "Відсутність на відповідях 401"
			},
			"contentType": {
				"description": "Вказує медіа-тип ресурсу.",
				"whenToUse1": "Тип контенту тіла запиту (POST, PUT, PATCH)",
				"whenToUse2": "Тип контенту тіла відповіді",
				"mistakes1": "Відсутність charset для текстових типів",
				"mistakes2": "Невірний MIME тип (наприклад, application/json vs text/json)"
			},
			"accept": {
				"description": "Вказує медіа-типи, прийнятні для відповіді.",
				"whenToUse1": "Клієнт вказує бажаний формат відповіді",
				"mistakes1": "Не вказують заголовок Accept, коли формат важливий"
			},
			"acceptEncoding": {
				"description": "Повідомляє сервер, які методи стиснення підтримує клієнт.",
				"whenToUse1": "Для зменшення розміру відповідей і покращення продуктивності.",
				"mistakes1": "Відсутність gzip/br при великих payload",
				"mistakes2": "Сервер ігнорує заголовок",
				"security": "Стиснення може впливати на деякі атаки (наприклад, BREACH)."
			},
			"acceptLanguage": {
				"description": "Вказує мови, яким надає перевагу клієнт.",
				"whenToUse1": "Для локалізації API-відповідей або контенту.",
				"mistakes1": "Ігнорування заголовка сервером",
				"mistakes2": "Відсутній fallback-механізм",
				"security": "Може використовуватись для fingerprinting користувача."
			},
			"contentEncoding": {
				"description": "Вказує перетворення кодування, застосовані до тіла повідомлення.",
				"whenToUse1": "Стиснуті відповіді (gzip, br, deflate)",
				"mistakes1": "Невідповідність Content-Encoding з фактичним кодуванням"
			},
			"contentLength": {
				"description": "Розмір тіла повідомлення в байтах.",
				"whenToUse1": "Вказівка розміру тіла запиту/відповіді",
				"mistakes1": "Невірна довжина, що викликає проблеми з'єднання"
			},
			"cacheControl": {
				"description": "Директиви для механізмів кешування в запитах та відповідях.",
				"whenToUse1": "Контроль поведінки кешування (public, private, no-cache, max-age)",
				"whenToUse2": "Відповіді API, які не повинні кешуватися",
				"mistakes1": "Кешування чутливих даних",
				"mistakes2": "Відсутність Cache-Control на відповідях API"
			},
			"etag": {
				"description": "Тег сутності для валідації кешу.",
				"whenToUse1": "Умовні запити та валідація кешу",
				"mistakes1": "Слабкі ETag, коли потрібні сильні"
			},
			"lastModified": {
				"description": "Вказує дату та час останньої зміни ресурсу.",
				"whenToUse1": "Для HTTP-кешування, умовних запитів (If-Modified-Since) та оптимізації трафіку.",
				"mistakes1": "Відсутній для статичних ресурсів",
				"mistakes2": "Неправильний формат дати",
				"security": "Може непрямо розкривати інформацію про частоту оновлення ресурсу."
			},
			"ifNoneMatch": {
				"description": "Умовний запит з використанням ETag для валідації кешу.",
				"whenToUse1": "Перевірка, чи змінився ресурс з останнього запиту",
				"mistakes1": "Не обробка відповідей 304 Not Modified"
			},
			"expires": {
				"description": "Дата/час, після якого відповідь вважається застарілою.",
				"whenToUse1": "Застаріле закінчення кешу (краще використовувати Cache-Control)",
				"mistakes1": "Використання Expires замість Cache-Control"
			},
			"vary": {
				"description": "Заголовки, що впливають на вибір відповіді.",
				"whenToUse1": "CORS відповіді з credentials та конкретним origin",
				"mistakes1": "Відсутність Vary: Origin, коли потрібно"
			},
			"origin": {
				"description": "Origin запиту (схема, хост, порт).",
				"whenToUse1": "CORS запити з браузерів"
			},
			"accessControlAllowOrigin": {
				"description": "Вказує дозволені origins для CORS запитів.",
				"whenToUse1": "CORS-увімкнені відповіді API",
				"mistakes1": "Використання * з credentials (не дозволено)",
				"mistakes2": "Не валідація origin на стороні сервера"
			},
			"accessControlAllowCredentials": {
				"description": "Вказує, чи можуть бути включені credentials у CORS запити.",
				"whenToUse1": "CORS запити, які потребують cookies або auth заголовків",
				"mistakes1": "Встановлення true з ACAO=\"*\" (невалідно)"
			},
			"accessControlAllowHeaders": {
				"description": "Заголовки, дозволені в CORS запитах.",
				"whenToUse1": "CORS preflight відповіді"
			},
			"accessControlAllowMethods": {
				"description": "HTTP методи, дозволені в CORS запитах.",
				"whenToUse1": "CORS preflight відповіді"
			},
			"accessControlExposeHeaders": {
				"description": "Заголовки, доступні JavaScript у CORS відповідях.",
				"whenToUse1": "CORS відповіді, що експортують кастомні заголовки"
			},
			"accessControlMaxAge": {
				"description": "Визначає, як довго браузер кешує CORS preflight-відповідь.",
				"whenToUse1": "Для зменшення кількості OPTIONS-запитів.",
				"mistakes1": "Не заданий → зайві preflight-запити",
				"mistakes2": "Надто велике значення",
				"security": "Зміни CORS-політик можуть застосовуватись із затримкою."
			},
			"setCookie": {
				"description": "Встановлює cookie в браузері.",
				"whenToUse1": "Управління сесіями, налаштування, відстеження",
				"mistakes1": "SameSite=None без Secure",
				"mistakes2": "Відсутність HttpOnly для сесійних cookie",
				"mistakes3": "Не встановлення відповідного терміну дії",
				"security": "Використовуйте HttpOnly для сесійних cookie, Secure для HTTPS-only, та відповідні значення SameSite."
			},
			"cookie": {
				"description": "Містить збережені cookie для домену.",
				"whenToUse1": "Відправка cookie з запитами"
			},
			"contentSecurityPolicy": {
				"description": "Контролює ресурси, які браузер може завантажити для запобігання XSS.",
				"whenToUse1": "Веб-сторінки, які потребують захисту від XSS",
				"mistakes1": "Занадто обмежена політика, що ламає функціональність",
				"security": "Почніть з default-src 'self' та поступово додавайте потрібні джерела."
			},
			"strictTransportSecurity": {
				"description": "Примушує HTTPS з'єднання для домену.",
				"whenToUse1": "Сайти тільки з HTTPS",
				"mistakes1": "Включення піддоменів, коли не готові",
				"security": "Використовуйте max-age принаймні 31536000 (1 рік) та includeSubDomains, коли доречно."
			},
			"xFrameOptions": {
				"description": "Запобігає атакам clickjacking шляхом контролю фреймування.",
				"whenToUse1": "Сторінки, які не повинні бути вбудовані в iframe",
				"mistakes1": "Використання DENY, коли достатньо SAMEORIGIN"
			},
			"xContentTypeOptions": {
				"description": "Запобігає атакам MIME type sniffing.",
				"whenToUse1": "Всі HTML відповіді",
				"mistakes1": "Відсутність на HTML контенті"
			},
			"referrerPolicy": {
				"description": "Контролює інформацію referrer, що відправляється з запитами.",
				"whenToUse1": "Додатки, чутливі до конфіденційності"
			},
			"permissionsPolicy": {
				"description": "Контролює функції браузера та API, доступні для сторінки.",
				"whenToUse1": "Обмеження доступу до функцій браузера"
			},
			"location": {
				"description": "URL для відповідей перенаправлення.",
				"whenToUse1": "3xx відповіді перенаправлення",
				"mistakes1": "Відносні URL, коли потрібні абсолютні"
			},
			"retryAfter": {
				"description": "Час очікування перед повторним запитом.",
				"whenToUse1": "429 Too Many Requests або 503 Service Unavailable"
			},
			"xForwardedFor": {
				"description": "Оригінальна IP адреса клієнта за проксі.",
				"whenToUse1": "Проксовані запити",
				"mistakes1": "Довіряння без валідації (ризик безпеки)"
			},
			"xForwardedProto": {
				"description": "Оригінальний протокол (http/https) за проксі.",
				"whenToUse1": "Проксовані запити"
			},
			"forwarded": {
				"description": "Стандартизована інформація про проксі (замінює X-Forwarded-*).",
				"whenToUse1": "Проксовані запити (краще за X-Forwarded-*)"
			},
			"serverTiming": {
				"description": "Метрики продуктивності з сервера.",
				"whenToUse1": "Моніторинг та відлагодження продуктивності"
			},
			"pragma": {
				"description": "Кеш-контроль зі старих часів (HTTP/1.0). Часто використовується як no-cache.",
				"whenToUse1": "Для сумісності зі старими проксі/клієнтами, разом із Cache-Control.",
				"mistakes1": "Покладатись на Pragma замість Cache-Control (сучасні браузери дивляться саме Cache-Control)."
			},
			"date": {
				"description": "Час формування відповіді на сервері (GMT).",
				"whenToUse1": "Для дебагу кешу, синхронізації часу, логів, CDN.",
				"mistakes1": "Неправильний час на сервері → дивні TTL/кеш-ефекти й проблеми з підписами (JWT, signed URLs)."
			},
			"server": {
				"description": "Інформація про сервер/проксі (наприклад envoy, nginx, cloudflare).",
				"whenToUse1": "Для діагностики інфраструктури (що відповідає реально: app чи proxy).",
				"mistakes1": "Зайва деталізація може допомагати атакуючим; часто цей header приховують/скорочують у проді."
			},
			"xEnvoyUpstreamServiceTime": {
				"description": "Скільки часу upstream (твій бекенд) обробляв запит всередині Envoy (мс).",
				"whenToUse1": "Дебаг перформансу: відділити затримку бекенду від мережі/проксі.",
				"mistakes1": "Плутати з загальним часом відповіді в браузері — це лише частина шляху (без клієнта, TLS, network, тощо)."
			},
			"xXssProtection": {
				"description": "Старий механізм \"XSS-фільтра\" в деяких браузерах.",
				"whenToUse1": "По суті — не потрібно. У сучасних браузерах неактуально/ігнорується.",
				"mistakes1": "Думати, що це реально захищає від XSS. Реальний захист — це CSP + escaping + правильний рендерінг.",
				"security": "Часто ставлять X-XSS-Protection: 0, щоб вимкнути старі \"фільтри\", які інколи робили гірше."
			},
			"referer": {
				"description": "Передає URL сторінки, з якої було здійснено запит.",
				"whenToUse1": "Для аналітики, логування, анти-CSRF механізмів.",
				"mistakes1": "Очікування Referer, коли його блокує Referrer-Policy",
				"mistakes2": "Покладання на нього як на механізм безпеки",
				"security": "Може розкривати чутливі URL або параметри запиту."
			},
			"userAgent": {
				"description": "Ідентифікує клієнт, браузер або тип запиту.",
				"whenToUse1": "Для діагностики, аналітики або тимчасових workaround-рішень.",
				"mistakes1": "Логіка доступу на основі User-Agent",
				"security": "Легко підміняється — не використовувати для автентифікації."
			}
		},
		"whatIs": "Що таке Інспектор заголовків?",
		"whatIsDescription": "Інспектор заголовків — локальний інструмент, який перетворює HTTP-заголовки запиту або відповіді на зрозумілий список з поясненнями та підказками. Допомагає швидко знаходити типові проблеми з CORS, кешуванням, Content-Type та cookies під час дебагу API і QA-тестування — прямо у браузері.",
		"whatYouCanDo": "Що можна зробити в інструменті",
		"whatYouCanDo1": "Вставити заголовки і миттєво розпарсити їх у пари ключ/значення",
		"whatYouCanDo2": "Перемкнути режим Запит / Відповідь",
		"whatYouCanDo3": "Побачити знайдені проблеми (error/warning/info) та рекомендації",
		"whatYouCanDo4": "Відкрити будь-який заголовок і отримати коротке пояснення + типові помилки",
		"whatYouCanDo5": "Скопіювати назву, значення або рядок Заголовок: значення",
		"privacy": "Приватність",
		"privacyText": "Усі дані обробляються локально у вашому браузері. Дані не відправляються на сервер."
	},
	"privacy": {
		"title": "Конфіденційність - QA Toolbox",
		"description": "Політика конфіденційності для QA Toolbox. Ми не збираємо, не зберігаємо та не передаємо жодних даних."
	}
}
