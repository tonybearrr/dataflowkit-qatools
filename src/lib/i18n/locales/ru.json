{
	"common": {
		"qaToolbox": "QA Toolbox",
		"madeBy": "Создано Антоном",
		"donate": "Поддержать",
		"privacy": "Политика конфиденциальности",
		"about": "О проекте",
		"privacyFirst": "Работает локально в вашем браузере. Без отслеживания. Без аккаунтов.",
		"noTracking": "Без отслеживания",
		"localOnly": "Только локально",
		"builtBy": "Часть",
		"moreToolsComing": "Больше инструментов скоро...",
		"copy": "Копировать",
		"clear": "Очистить",
		"parse": "Распарсить"
	},
	"nav": {
		"testDataGenerator": "Тестовые данные",
		"apiResponseValidator": "Валидатор API",
		"statusCodeReference": "Статус-коды",
		"userAgentParser": "User Agent"
	},
	"home": {
		"title": "QA Toolbox",
		"description": "Быстрые инструменты для QA-тестирования с приоритетом конфиденциальности. Без бэкенда. Без отслеживания. Всё работает локально в вашем браузере.",
		"testDataGenerator": {
			"title": "Генератор тестовых данных",
			"description": "Генерируйте тестовые данные: email, номера телефонов, UUID, имена, адреса и другое.",
			"tags": ["Email", "Телефон", "UUID"]
		},
		"apiResponseValidator": {
			"title": "Валидатор ответов API",
			"description": "Валидируйте JSON-ответы по схеме. Проверяйте структуру, типы и обязательные поля.",
			"tags": ["JSON Schema", "Валидация", "API"]
		},
		"statusCodeReference": {
			"title": "Справочник статус-кодов",
			"description": "Быстрый справочник HTTP статус-кодов с описанием и примерами использования.",
			"tags": ["HTTP", "Статус", "Справочник"]
		},
		"userAgentParser": {
			"title": "Парсер User-Agent",
			"description": "Распарсите строки User-Agent для извлечения информации о браузере, ОС, устройстве и версии.",
			"tags": ["Браузер", "ОС", "Устройство"]
		}
	},
	"testDataGenerator": {
		"title": "Генератор тестовых данных - QA Toolbox",
		"description": "Генерируйте тестовые данные локально: email, номера телефонов, UUID, имена, адреса и другое. Данные не отправляются на серверы.",
		"heading": "Генератор тестовых данных",
		"subtitle": "Test Data Generator — инструмент для генерации тестовых данных без бэкенда. Позволяет задать схему, просмотреть результат и экспортировать данные в JSON или CSV для тестирования, API и разработки.",
		"whatIsTestData": "Что такое генерация тестовых данных?",
		"testDataDescription": "Генерация тестовых данных — это процесс создания реалистичных, структурированных данных для тестирования. Этот инструмент позволяет определить схему с разными типами полей (строки, числа, даты, email и т.д.) и генерировать несколько строк данных, которые соответствуют вашим требованиям.",
		"parameters": "Параметры",
		"presets": "Пресеты",
		"presetsDescription": "Готовые шаблоны схем:",
		"presetsList": "User, Order, Address, Event",
		"fields": "Поля",
		"fieldName": "Имя поля — ключ в итоговых данных",
		"fieldType": "Тип — тип данных (uuid, email, name, phone, address, date, string)",
		"fieldRequired": "Обязательное — поле всегда присутствует",
		"fieldManage": "Порядок / Дублирование / Удаление — управление структурой",
		"preview": "Предпросмотр",
		"previewDescription": "Таблица сгенерированных данных",
		"previewRegenerate": "Regenerate — пересоздать данные с той же схемой",
		"export": "Экспорт",
		"exportRows": "Rows — количество записей",
		"exportSeed": "Seed — фиксированное значение для воспроизводимых результатов",
		"exportFormat": "Формат — JSON или CSV",
		"exportArrayKey": "Array key (необязательно) — оборачивает массив в объект",
		"exportActions": "Copy / Download — копирование или скачивание файла",
		"features": "Возможности",
		"featureSchema": "Определение пользовательских схем с разными типами полей",
		"featureSeed": "Использование seed для воспроизводимых, детерминированных данных",
		"featureExport": "Экспорт в форматы JSON или CSV",
		"featureLocal": "Вся обработка происходит локально в вашем браузере",
		"useCases": "Сценарии использования",
		"useCase1": "Создание тестовых наборов данных для тестирования API",
		"useCase2": "Генерация образцовых данных для заполнения базы данных",
		"useCase3": "Создание мок-данных для фронтенд разработки",
		"useCase4": "Создание тестовых фикстур для автоматизированного тестирования",
		"privacy": "Приватность",
		"privacyText": "Все данные генерируются локально в браузере. Ничего не отправляется на сервер.",
		"confirmReplaceTitle": "Заменить схему?",
		"confirmReplaceMessage": "Это заменит вашу текущую схему. Продолжить?",
		"confirmCancel": "Отмена",
		"confirmContinue": "Продолжить"
	},
	"payloadBuilder": {
		"title": "Payload Builder - QA Toolbox",
		"description": "Создавайте и ломайте JSON payload для тестирования API. Генерируйте невалидные варианты для тестирования валидации.",
		"heading": "Payload Builder + Breaker",
		"subtitle": "Создавайте JSON payload визуально или в коде. Генерируйте невалидные варианты для тестирования валидации API.",
		"whatIsPayloadBuilder": "Что такое Payload Builder + Breaker?",
		"payloadBuilderDescription": "Payload Builder + Breaker — локальный инструмент для создания и намеренного ломания JSON payload'ов для тестирования API. Создавайте валидные payload'ы визуально или в JSON и генерируйте невалидные варианты для проверки валидации и обработки ошибок. Вся обработка происходит локально в браузере.",
		"parameters": "Параметры",
		"templates": "Шаблоны",
		"templatesDescription": "Готовые payload'ы для типовых API-запросов",
		"templatesList": "",
		"jsonEditor": "JSON Editor",
		"jsonEditorDescription": "Редактирование, форматирование и минификация JSON с валидацией",
		"treeBuilder": "Tree Builder",
		"treeBuilderDescription": "Визуальное построение JSON-структур",
		"breaker": "Варианты (Breaker)",
		"breakerDescription": "Генерация ошибочных payload'ов (отсутствующие поля, неверные типы, null, edge cases)",
		"breakerPresets": "",
		"breakerPresetsList": "",
		"output": "Output",
		"outputDescription": "Просмотр, сравнение, копирование и экспорт payload'ов",
		"privacy": "Приватность",
		"privacyText": "Все данные обрабатываются локально в браузере. Данные не отправляются на сервер."
	},
	"apiResponseValidator": {
		"title": "Валидатор ответов API - QA Toolbox",
		"description": "API Validator — это инструмент для разработчиков и QA-инженеров, предназначенный для проверки соответствия JSON-payload ожидаемому контракту, описанному с помощью JSON Schema. Он подсвечивает ошибки валидации, проблемы схемы и форматирования, помогая находить ошибки ещё до отправки запроса на бэкенд. Вся проверка выполняется локально в браузере — быстро и без передачи данных на сервер.",
		"heading": "API Validator",
		"subtitle": "API Validator помогает проверять JSON-payload запросов на соответствие JSON Schema прямо в браузере. Быстро выявляйте несоответствия схеме, некорректные типы данных и отсутствующие обязательные поля при разработке API и QA-тестировании.",
		"payloadLabel": "Payload JSON",
		"outputLabel": "Output",
		"schemaLabel": "Schema JSON",
		"validate": "Валидировать",
		"autoValidate": "Авто-валидация",
		"formatPayload": "Форматировать Payload",
		"formatSchema": "Форматировать Schema",
		"selectPreset": "Sample Schema",
		"reset": "Сбросить",
		"valid": "Валидный",
		"invalid": "Невалидный",
		"parseError": "Ошибка парсинга",
		"schemaParseError": "Ошибка парсинга Schema",
		"line": "Строка",
		"column": "Колонка",
		"error": "ошибка",
		"errors": "ошибок",
		"keyword": "Ключевое слово",
		"expected": "Ожидалось",
		"received": "Получено",
		"copy": "Копировать",
		"copied": "Скопировано!",
		"copyError": "Копировать ошибку",
		"noValidation": "Нажмите Валидировать для проверки JSON по схеме",
		"formattedOutput": "Отформатированный вывод",
		"whatIs": "Что такое API Validator?",
		"parameters": "Параметры",
		"payloadDesc": "JSON payload для валидации",
		"schemaDesc": "JSON Schema (draft 2020-12 или draft-07)",
		"autoValidateDesc": "Автоматически валидировать при изменении ввода",
		"presets": "Presets",
		"presetsDesc": "Готовые схемы и payload'ы для типовых API-запросов",
		"format": "Форматирование",
		"formatDesc": "Форматировать JSON с правильными отступами",
		"privacy": "Приватность",
		"privacyText": "Вся валидация происходит локально в браузере. Данные не отправляются на сервер.",
		"useCases": "Сценарии использования",
		"useCasesSubtitle": "Используйте API Validator для:",
		"useCase1": "проверки JSON запросов перед отправкой",
		"useCase2": "тестирования серверной валидации",
		"useCase3": "поиска ошибок в схеме или payload-e",
		"useCase4": "проверки обязательных полей, типов и форматов данных",
		"whyUse": "Зачем использовать этот инструмент?",
		"whyUse1": "Мгновенная проверка API payload-ов",
		"whyUse2": "Поддержка JSON Schema (draft-07, draft-2020-12)",
		"whyUse3": "Подходит для разработчиков и QA инженеров",
		"typicalWorkflow": "Типовой сценарий работы",
		"workflow1": "Вставьте или введите JSON payload",
		"workflow2": "Добавьте или выберите JSON Schema",
		"workflow3": "Нажмите Validate или включите авто-валидацию",
		"workflow4": "Просмотрите ошибки или статус валидности",
		"workflow5": "При необходимости скопируйте отформатированный результат"
	},
	"statusCodeReference": {
		"title": "HTTP Status Codes Explorer - QA Toolbox",
		"description": "Быстрый локальный справочник HTTP статус-кодов с описанием, примерами использования и шаблонами API ответов.",
		"heading": "HTTP Status Codes Explorer",
		"subtitle": "Быстрый справочник HTTP статус-кодов с описанием, примерами использования и рекомендуемыми API ответами.",
		"searchPlaceholder": "Поиск по коду или ключевому слову...",
		"categoryAll": "Все",
		"category1xx": "1xx",
		"category2xx": "2xx",
		"category3xx": "3xx",
		"category4xx": "4xx",
		"category5xx": "5xx",
		"commonOnly": "Только распространенные",
		"categoryLabel": {
			"informational": "Информационные",
			"success": "Успех",
			"redirection": "Перенаправление",
			"clientError": "Ошибка клиента",
			"serverError": "Ошибка сервера"
		},
		"whenToUse": "Когда использовать",
		"commonCauses": "Типичные причины",
		"whatToReturn": "Что возвращать",
		"testingChecklist": "Чек-лист для тестирования",
		"relatedCodes": "Связанные коды",
		"copyJson": "Копировать JSON",
		"copyTitle": "Копировать заголовок",
		"copied": "Скопировано!",
		"noResults": "Ничего не найдено",
		"noResultsSuggestion": "Попробуйте поиск: 404, not found, rate limit, unauthorized",
		"whatIs": "Что такое HTTP Status Codes Explorer?",
		"whatIsDescription": "HTTP Status Codes Explorer — это локальный инструмент для быстрого понимания HTTP статус-кодов, их типичных причин и рекомендуемых API ответов. Помогает QA инженерам, разработчикам и бэкенд инженерам принимать обоснованные решения относительно выбора статус-кодов и структуры ответов об ошибках.",
		"qaUsage": "Как QA использует статус-коды в тестировании API",
		"qaUsageDescription": "QA инженеры используют статус-коды для проверки поведения API, тестирования обработки ошибок и обеспечения правильных форматов ответов. Этот инструмент помогает определить правильный статус-код для различных сценариев и предоставляет примеры ответов для тестирования.",
		"commonMistakes": "Типичные ошибки: 401 vs 403, 409 vs 422, 502 vs 504",
		"commonMistakesDescription": "401 (Unauthorized) означает, что аутентификация отсутствует или невалидна, тогда как 403 (Forbidden) означает, что пользователь аутентифицирован, но не имеет разрешения. 409 (Conflict) указывает на конфликт состояния, тогда как 422 (Unprocessable Entity) означает, что запрос правильно сформирован, но семантически невалиден. 502 (Bad Gateway) — это ошибка upstream сервера, тогда как 504 (Gateway Timeout) означает, что upstream сервер не ответил вовремя.",
		"statusCodes": {
			"100": {
				"summary": "Продолжить. Сервер получил заголовки запроса, и клиент должен продолжить отправку тела запроса.",
				"whenToUse1": "Заголовок Expect указывает, что клиент отправит тело",
				"whenToUse2": "Большая загрузка тела запроса",
				"causes1": "Клиент отправил заголовок Expect: 100-continue",
				"causes2": "Сервер готов получить тело запроса",
				"checklist1": "Проверьте, что клиент обрабатывает ответ 100",
				"checklist2": "Проверьте, что тело запроса отправляется после 100"
			},
			"101": {
				"summary": "Переключение протоколов. Сервер переключает протоколы по запросу клиента.",
				"whenToUse1": "Обновление до WebSocket",
				"whenToUse2": "Запрос на обновление протокола",
				"causes1": "Клиент запросил обновление протокола",
				"checklist1": "Проверьте, что обновление протокола успешно"
			},
			"200": {
				"summary": "Запрос успешен. Стандартный ответ для успешных HTTP запросов.",
				"whenToUse1": "Успешные GET, PUT или PATCH запросы",
				"whenToUse2": "Возврат данных в теле ответа",
				"whenToUse3": "Стандартный успешный ответ",
				"causes1": "Нормальная успешная обработка запроса",
				"causes2": "Ресурс успешно получен или обновлен",
				"checklist1": "Проверьте, что тело ответа содержит ожидаемые данные",
				"checklist2": "Проверьте, что заголовок Content-Type соответствует формату ответа",
				"checklist3": "Убедитесь, что ответ правильно отформатирован"
			},
			"201": {
				"summary": "Ресурс успешно создан. Обычно используется после POST запросов, которые создают новые ресурсы.",
				"whenToUse1": "После успешного POST запроса, создающего новый ресурс",
				"whenToUse2": "Когда возвращается созданный ресурс в теле ответа",
				"causes1": "Новый ресурс успешно создан",
				"causes2": "Создание ресурса с заголовком Location",
				"checklist1": "Проверьте, что заголовок Location указывает на новый ресурс",
				"checklist2": "Проверьте, что тело ответа содержит созданный ресурс",
				"checklist3": "Убедитесь, что ID ресурса включен"
			},
			"204": {
				"summary": "Запрос успешен, но нет содержимого для возврата. Используется для успешных операций, которые не требуют тела ответа.",
				"whenToUse1": "Успешные DELETE запросы",
				"whenToUse2": "Успешные PUT/PATCH без необходимости ответа",
				"causes1": "Операция успешно завершена без содержимого",
				"checklist1": "Проверьте, что тело ответа пустое",
				"checklist2": "Проверьте, что операция действительно успешна"
			},
			"202": {
				"summary": "Принято. Запрос принят для обработки, но обработка еще не завершена.",
				"whenToUse1": "Асинхронная обработка запроса",
				"whenToUse2": "Запрос поставлен в очередь для фоновой обработки",
				"causes1": "Запрос принят, но еще не обработан",
				"checklist1": "Проверьте, что запрос действительно обрабатывается",
				"checklist2": "Проверьте, предоставлена ли конечная точка статуса"
			},
			"301": {
				"summary": "Перемещено навсегда. Ресурс был постоянно перемещен на новый адрес.",
				"whenToUse1": "Ресурс постоянно перемещен на новый URL",
				"whenToUse2": "Структура URL изменена навсегда",
				"causes1": "Местоположение ресурса изменено",
				"causes2": "Реструктуризация домена или пути",
				"checklist1": "Проверьте, что заголовок Location указывает на новый URL",
				"checklist2": "Проверьте, что перенаправление постоянное"
			},
			"302": {
				"summary": "Найдено (временное перенаправление). Ресурс временно расположен по другому адресу.",
				"whenToUse1": "Временное перемещение ресурса",
				"whenToUse2": "Временное изменение URL",
				"causes1": "Ресурс временно перемещен",
				"causes2": "Обслуживание или балансировка нагрузки",
				"checklist1": "Проверьте, что заголовок Location присутствует",
				"checklist2": "Проверьте метод перенаправления (GET vs POST)"
			},
			"304": {
				"summary": "Не изменено. Ресурс не изменялся с момента последнего запроса.",
				"whenToUse1": "Условный GET с If-None-Match или If-Modified-Since",
				"whenToUse2": "Кэшированный ресурс все еще валиден",
				"causes1": "Ресурс не изменялся с момента последнего запроса",
				"checklist1": "Проверьте заголовки ETag или Last-Modified",
				"checklist2": "Проверьте, что тело ответа пустое"
			},
			"307": {
				"summary": "Временное перенаправление. Запрос должен быть повторен с тем же HTTP методом.",
				"whenToUse1": "Временное перенаправление с сохранением метода",
				"whenToUse2": "Балансировка нагрузки или обслуживание",
				"causes1": "Временное перемещение сервера",
				"checklist1": "Проверьте, что HTTP метод сохранен",
				"checklist2": "Проверьте заголовок Location"
			},
			"308": {
				"summary": "Постоянное перенаправление. Запрос и все будущие запросы должны быть повторены с использованием предоставленного URI.",
				"whenToUse1": "Постоянное перенаправление с сохранением метода",
				"whenToUse2": "Постоянное изменение URL",
				"causes1": "Постоянное перемещение ресурса",
				"checklist1": "Проверьте, что метод и тело сохранены",
				"checklist2": "Проверьте, что перенаправление действительно постоянное"
			},
			"400": {
				"summary": "Неверный синтаксис запроса или параметры. Сервер не может обработать запрос из-за ошибки клиента.",
				"whenToUse1": "Неверный синтаксис запроса",
				"whenToUse2": "Неверные параметры запроса",
				"whenToUse3": "Отсутствуют обязательные поля",
				"causes1": "Неверный синтаксис JSON",
				"causes2": "Отсутствуют обязательные параметры",
				"causes3": "Неверные типы параметров",
				"causes4": "Неверно сформированное тело запроса",
				"checklist1": "Проверьте, что сообщение об ошибке объясняет проблему",
				"checklist2": "Проверьте, что ответ об ошибке включает requestId",
				"checklist3": "Убедитесь, что формат ошибки согласован",
				"checklist4": "Тестируйте с различными невалидными входами"
			},
			"401": {
				"summary": "Требуется аутентификация или она не удалась. Клиент должен аутентифицироваться для получения запрашиваемого ответа.",
				"whenToUse1": "Отсутствует или невалиден токен аутентификации",
				"whenToUse2": "Срок действия учетных данных аутентификации истек",
				"whenToUse3": "Схема аутентификации не поддерживается",
				"causes1": "Заголовок Authorization не предоставлен",
				"causes2": "Невалидный или устаревший токен",
				"causes3": "Учетные данные аутентификации неверны",
				"checklist1": "Проверьте, что заголовок WWW-Authenticate присутствует",
				"checklist2": "Проверьте, что сообщение об ошибке не раскрывает чувствительную информацию",
				"checklist3": "Тестируйте с отсутствующими, невалидными и устаревшими токенами",
				"checklist4": "Убедитесь, что используется 401, а не 403 для проблем с аутентификацией"
			},
			"403": {
				"summary": "Доступ запрещен. Клиент не имеет разрешения на доступ к ресурсу.",
				"whenToUse1": "Пользователь аутентифицирован, но не имеет разрешения",
				"whenToUse2": "Ресурс существует, но доступ запрещен",
				"whenToUse3": "Недостаточно привилегий для операции",
				"causes1": "Пользователь не имеет необходимых разрешений",
				"causes2": "Доступ к ресурсу ограничен политикой",
				"causes3": "Операция не разрешена для роли пользователя",
				"checklist1": "Проверьте, что пользователь аутентифицирован (не 401)",
				"checklist2": "Проверьте, что сообщение об ошибке объясняет проблему с разрешениями",
				"checklist3": "Тестируйте с различными ролями пользователей"
			},
			"404": {
				"summary": "Ресурс не найден. Сервер не может найти запрашиваемый ресурс.",
				"whenToUse1": "Ресурс не существует",
				"whenToUse2": "Неверный ID ресурса или путь",
				"whenToUse3": "Конечная точка не существует",
				"causes1": "Ресурс был удален",
				"causes2": "Неверный URL или ID ресурса",
				"causes3": "Ресурс никогда не существовал",
				"causes4": "Ошибка в пути запроса",
				"checklist1": "Проверьте, что сообщение об ошибке понятно",
				"checklist2": "Проверьте, что ответ не раскрывает внутреннюю структуру",
				"checklist3": "Тестируйте с различными невалидными ID"
			},
			"405": {
				"summary": "Метод не разрешен. HTTP метод не разрешен для запрашиваемого ресурса.",
				"whenToUse1": "HTTP метод не поддерживается для конечной точки",
				"whenToUse2": "Конечная точка существует, но метод неверен",
				"causes1": "Метод не реализован для ресурса",
				"causes2": "Разрешены только определенные методы",
				"checklist1": "Проверьте, что заголовок Allow перечисляет разрешенные методы",
				"checklist2": "Тестируйте с различными HTTP методами"
			},
			"408": {
				"summary": "Тайм-аут запроса. Сервер не дождался запроса.",
				"whenToUse1": "Клиент слишком долго отправлял запрос",
				"whenToUse2": "Тайм-аут запроса до завершения",
				"causes1": "Клиент не отправил запрос вовремя",
				"causes2": "Тайм-аут сетевого соединения",
				"checklist1": "Проверьте конфигурацию тайм-аута",
				"checklist2": "Тестируйте с медленными соединениями"
			},
			"409": {
				"summary": "Конфликт ресурса. Запрос конфликтует с текущим состоянием ресурса.",
				"whenToUse1": "Дублирование создания ресурса",
				"whenToUse2": "Конфликт одновременного изменения",
				"whenToUse3": "Конфликт состояния (например, удаление активного ресурса)",
				"causes1": "Ресурс уже существует с таким же идентификатором",
				"causes2": "Конфликт оптимистичной блокировки",
				"causes3": "Нарушение бизнес-правил",
				"checklist1": "Проверьте, что ошибка объясняет конфликт",
				"checklist2": "Проверьте, нужна ли логика повторной попытки",
				"checklist3": "Тестируйте сценарии одновременного изменения"
			},
			"410": {
				"summary": "Удалено. Ресурс больше недоступен и не будет доступен снова.",
				"whenToUse1": "Ресурс постоянно удален",
				"whenToUse2": "Ресурс удален и не вернется",
				"causes1": "Ресурс постоянно удален",
				"causes2": "Ресурс устарел и удален",
				"checklist1": "Проверьте, что ресурс не будет восстановлен",
				"checklist2": "Проверьте, что сообщение об ошибке объясняет удаление"
			},
			"412": {
				"summary": "Условие не выполнено. Одно или более условий в полях заголовков запроса оценено как ложные.",
				"whenToUse1": "Условие If-Match или If-None-Match не выполнено",
				"whenToUse2": "Условие If-Unmodified-Since не выполнено",
				"causes1": "Несоответствие ETag",
				"causes2": "Ресурс изменен с момента последнего запроса",
				"checklist1": "Проверьте заголовки условий",
				"checklist2": "Тестируйте сценарии оптимистичной блокировки"
			},
			"413": {
				"summary": "Тело запроса слишком большое. Сущность запроса больше лимитов, определенных сервером.",
				"whenToUse1": "Тело запроса превышает лимит размера",
				"whenToUse2": "Файл для загрузки слишком большой",
				"causes1": "Тело запроса превышает лимит сервера",
				"causes2": "Размер файла слишком большой",
				"checklist1": "Проверьте, что лимит размера задокументирован",
				"checklist2": "Тестируйте с различными размерами тела запроса"
			},
			"415": {
				"summary": "Неподдерживаемый тип медиа. Сущность запроса имеет тип медиа, который сервер не поддерживает.",
				"whenToUse1": "Неверный заголовок Content-Type",
				"whenToUse2": "Сервер принимает только определенные типы медиа",
				"causes1": "Content-Type не поддерживается (например, XML вместо JSON)",
				"causes2": "Отсутствует или неверный заголовок Content-Type",
				"checklist1": "Проверьте, что заголовок Accept проверяется",
				"checklist2": "Тестируйте с различными значениями Content-Type"
			},
			"422": {
				"summary": "Необрабатываемая сущность. Запрос правильно сформирован, но семантически невалиден.",
				"whenToUse1": "Ошибки валидации в теле запроса",
				"whenToUse2": "Валидация бизнес-логики не удалась",
				"whenToUse3": "Семантические ошибки (например, невалидный диапазон дат)",
				"causes1": "Валидация поля не удалась",
				"causes2": "Нарушение бизнес-правил",
				"causes3": "Неверные связи данных",
				"checklist1": "Проверьте, что детали ошибки указывают конкретные поля",
				"checklist2": "Проверьте, что формат ошибки включает ошибки на уровне полей",
				"checklist3": "Тестируйте с различными сценариями валидации",
				"checklist4": "Убедитесь, что используется 422, а не 400 для валидации"
			},
			"429": {
				"summary": "Слишком много запросов. Пользователь отправил слишком много запросов за определенное время.",
				"whenToUse1": "Превышен лимит скорости",
				"whenToUse2": "Слишком много запросов с того же IP/пользователя",
				"causes1": "Превышен порог лимита скорости",
				"causes2": "Слишком частые вызовы API",
				"causes3": "Сработала защита от DDoS",
				"checklist1": "Проверьте, что заголовок Retry-After присутствует",
				"checklist2": "Проверьте, что сообщение об ошибке включает информацию о лимите скорости",
				"checklist3": "Тестируйте поведение ограничения скорости"
			},
			"500": {
				"summary": "Внутренняя ошибка сервера. Сервер столкнулся с неожиданным условием.",
				"whenToUse1": "Неожиданная ошибка сервера",
				"whenToUse2": "Необработанное исключение",
				"causes1": "Ошибка кода приложения",
				"causes2": "Сбой подключения к базе данных",
				"causes3": "Сбой стороннего сервиса",
				"causes4": "Ошибка конфигурации",
				"checklist1": "Проверьте, что ошибка не раскрывает чувствительную информацию",
				"checklist2": "Проверьте, что requestId включен для отладки",
				"checklist3": "Убедитесь в правильном логировании ошибок"
			},
			"501": {
				"summary": "Не реализовано. Сервер не поддерживает функциональность, необходимую для выполнения запроса.",
				"whenToUse1": "Функция еще не реализована",
				"whenToUse2": "Метод не поддерживается сервером",
				"causes1": "Конечная точка или функция недоступна",
				"checklist1": "Проверьте, что функция действительно не реализована",
				"checklist2": "Проверьте, не более ли уместен 404"
			},
			"502": {
				"summary": "Плохой шлюз. Сервер, действующий как шлюз, получил невалидный ответ.",
				"whenToUse1": "Невалидный ответ от upstream сервера",
				"whenToUse2": "Ошибка upstream сервера",
				"causes1": "Upstream сервер вернул невалидный ответ",
				"causes2": "Проблема конфигурации прокси/шлюза",
				"causes3": "Сетевая проблема между серверами",
				"checklist1": "Проверьте, что сообщение об ошибке понятно",
				"checklist2": "Проверьте, уместна ли повторная попытка",
				"checklist3": "Тестируйте сбои upstream сервера"
			},
			"503": {
				"summary": "Сервис недоступен. Сервер временно не может обработать запрос.",
				"whenToUse1": "Сервис временно недоступен для обслуживания",
				"whenToUse2": "Сервер перегружен",
				"whenToUse3": "Временная недоступность",
				"causes1": "Запланированное обслуживание",
				"causes2": "Перегрузка сервера",
				"causes3": "Зависимый сервис недоступен",
				"checklist1": "Проверьте заголовок Retry-After, если применимо",
				"checklist2": "Проверьте, что сообщение об ошибке объясняет недоступность",
				"checklist3": "Тестируйте сценарии восстановления сервиса"
			},
			"504": {
				"summary": "Тайм-аут шлюза. Сервер, действующий как шлюз, не получил своевременный ответ.",
				"whenToUse1": "Тайм-аут upstream сервера",
				"whenToUse2": "Запрос занял слишком много времени для обработки",
				"causes1": "Upstream сервер не ответил вовремя",
				"causes2": "Сетевой тайм-аут",
				"causes3": "Медленная обработка upstream",
				"checklist1": "Проверьте конфигурацию тайм-аута",
				"checklist2": "Проверьте, можно ли оптимизировать запрос",
				"checklist3": "Тестируйте сценарии тайм-аута"
			}
		}
	},
	"userAgentParser": {
		"title": "Парсер User-Agent - QA Toolbox",
		"description": "Распарсите строки User-Agent для извлечения информации о браузере, ОС, устройстве и версии локально."
	},
	"privacy": {
		"title": "Конфиденциальность - QA Toolbox",
		"description": "Политика конфиденциальности для QA Toolbox. Мы не собираем, не храним и не передаём никаких данных."
	}
}
