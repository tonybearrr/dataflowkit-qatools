{
	"common": {
		"qaToolbox": "QA Toolbox",
		"madeBy": "Создано Антоном",
		"donate": "Поддержать",
		"privacy": "Политика конфиденциальности",
		"about": "О проекте",
		"privacyFirst": "Работает локально в вашем браузере. Без отслеживания. Без аккаунтов.",
		"noTracking": "Без отслеживания",
		"localOnly": "Только локально",
		"builtBy": "Часть",
		"moreToolsComing": "Больше инструментов скоро...",
		"copy": "Копировать",
		"clear": "Очистить",
		"parse": "Распарсить"
	},
	"nav": {
		"testDataGenerator": "Тестовые данные",
		"apiResponseValidator": "Валидатор API",
		"statusCodeReference": "Статус-коды",
		"userAgentParser": "User Agent",
		"headersInspector": "Headers",
		"cookieDebugger": "Cookies"
	},
	"home": {
		"title": "QA Toolbox",
		"description": "Быстрые инструменты для QA-тестирования с приоритетом конфиденциальности. Без бэкенда. Без отслеживания. Всё работает локально в вашем браузере.",
		"testDataGenerator": {
			"title": "Генератор тестовых данных",
			"description": "Генерируйте тестовые данные: email, номера телефонов, UUID, имена, адреса и другое.",
			"tags": ["Email", "Телефон", "UUID"]
		},
		"payloadBuilder": {
			"title": "Payload Builder + Breaker",
			"description": "Создавайте и ломайте JSON payload'ы для тестирования API. Создавайте невалидные варианты для проверки валидации.",
			"tags": ["JSON", "Тестирование API", "Валидация"]
		},
		"apiResponseValidator": {
			"title": "Валидатор ответов API",
			"description": "Валидируйте JSON-ответы по схеме. Проверяйте структуру, типы и обязательные поля.",
			"tags": ["JSON Schema", "Валидация", "API"]
		},
		"statusCodeReference": {
			"title": "Справочник статус-кодов",
			"description": "Быстрый справочник HTTP статус-кодов с описанием и примерами использования.",
			"tags": ["HTTP", "Статус", "Справочник"]
		},
		"userAgentParser": {
			"title": "Парсер User-Agent",
			"description": "Распарсите строки User-Agent для извлечения информации о браузере, ОС, устройстве и версии.",
			"tags": ["Браузер", "ОС", "Устройство"]
		},
		"headersInspector": {
			"title": "Инспектор заголовков",
			"description": "Парсинг и анализ HTTP заголовков. Поймите их назначение и обнаружьте проблемы конфигурации.",
			"tags": ["HTTP", "Заголовки", "CORS"]
		},
		"cookieDebugger": {
			"title": "Cookie Debugger",
			"description": "Парсинг и отладка файлов cookie локально. Поймите атрибуты, выявляйте проблемы и симулируйте отправку.",
			"tags": ["HTTP", "Cookies", "Безопасность"]
		}
	},
	"testDataGenerator": {
		"title": "Генератор тестовых данных - QA Toolbox",
		"description": "Генерируйте тестовые данные локально: email, номера телефонов, UUID, имена, адреса и другое. Данные не отправляются на серверы.",
		"heading": "Генератор тестовых данных",
		"subtitle": "Test Data Generator — инструмент для генерации тестовых данных без бэкенда. Позволяет задать схему, просмотреть результат и экспортировать данные в JSON или CSV для тестирования, API и разработки.",
		"whatIsTestData": "Что такое генерация тестовых данных?",
		"testDataDescription": "Генерация тестовых данных — это процесс создания реалистичных, структурированных данных для тестирования. Этот инструмент позволяет определить схему с разными типами полей (строки, числа, даты, email и т.д.) и генерировать несколько строк данных, которые соответствуют вашим требованиям.",
		"parameters": "Параметры",
		"presets": "Пресеты",
		"presetsDescription": "Готовые шаблоны схем:",
		"presetsList": "User, Order, Address, Event",
		"fields": "Поля",
		"fieldName": "Имя поля — ключ в итоговых данных",
		"fieldType": "Тип — тип данных (uuid, email, name, phone, address, date, string)",
		"fieldRequired": "Обязательное — поле всегда присутствует",
		"fieldManage": "Порядок / Дублирование / Удаление — управление структурой",
		"preview": "Предпросмотр",
		"previewDescription": "Таблица сгенерированных данных",
		"previewRegenerate": "Regenerate — пересоздать данные с той же схемой",
		"export": "Экспорт",
		"exportRows": "Rows — количество записей",
		"exportSeed": "Seed — фиксированное значение для воспроизводимых результатов",
		"exportFormat": "Формат — JSON или CSV",
		"exportArrayKey": "Array key (необязательно) — оборачивает массив в объект",
		"exportActions": "Copy / Download — копирование или скачивание файла",
		"features": "Возможности",
		"featureSchema": "Определение пользовательских схем с разными типами полей",
		"featureSeed": "Использование seed для воспроизводимых, детерминированных данных",
		"featureExport": "Экспорт в форматы JSON или CSV",
		"featureLocal": "Вся обработка происходит локально в вашем браузере",
		"useCases": "Сценарии использования",
		"useCase1": "Создание тестовых наборов данных для тестирования API",
		"useCase2": "Генерация образцовых данных для заполнения базы данных",
		"useCase3": "Создание мок-данных для фронтенд разработки",
		"useCase4": "Создание тестовых фикстур для автоматизированного тестирования",
		"privacy": "Приватность",
		"privacyText": "Все данные генерируются локально в браузере. Ничего не отправляется на сервер.",
		"confirmReplaceTitle": "Заменить схему?",
		"confirmReplaceMessage": "Это заменит вашу текущую схему. Продолжить?",
		"confirmCancel": "Отмена",
		"confirmContinue": "Продолжить"
	},
	"payloadBuilder": {
		"title": "Payload Builder - QA Toolbox",
		"description": "Создавайте и ломайте JSON payload для тестирования API. Генерируйте невалидные варианты для тестирования валидации.",
		"heading": "Payload Builder + Breaker",
		"subtitle": "Создавайте JSON payload визуально или в коде. Генерируйте невалидные варианты для тестирования валидации API.",
		"whatIsPayloadBuilder": "Что такое Payload Builder + Breaker?",
		"payloadBuilderDescription": "Payload Builder + Breaker — локальный инструмент для создания и намеренного ломания JSON payload'ов для тестирования API. Создавайте валидные payload'ы визуально или в JSON и генерируйте невалидные варианты для проверки валидации и обработки ошибок. Вся обработка происходит локально в браузере.",
		"parameters": "Параметры",
		"templates": "Шаблоны",
		"templatesDescription": "Готовые payload'ы для типовых API-запросов",
		"templatesList": "",
		"jsonEditor": "JSON Editor",
		"jsonEditorDescription": "Редактирование, форматирование и минификация JSON с валидацией",
		"treeBuilder": "Tree Builder",
		"treeBuilderDescription": "Визуальное построение JSON-структур",
		"breaker": "Варианты (Breaker)",
		"breakerDescription": "Генерация ошибочных payload'ов (отсутствующие поля, неверные типы, null, edge cases)",
		"breakerPresets": "",
		"breakerPresetsList": "",
		"output": "Output",
		"outputDescription": "Просмотр, сравнение, копирование и экспорт payload'ов",
		"privacy": "Приватность",
		"privacyText": "Все данные обрабатываются локально в браузере. Данные не отправляются на сервер."
	},
	"apiResponseValidator": {
		"title": "Валидатор ответов API - QA Toolbox",
		"description": "API Validator — это инструмент для разработчиков и QA-инженеров, предназначенный для проверки соответствия JSON-payload ожидаемому контракту, описанному с помощью JSON Schema. Он подсвечивает ошибки валидации, проблемы схемы и форматирования, помогая находить ошибки ещё до отправки запроса на бэкенд. Вся проверка выполняется локально в браузере — быстро и без передачи данных на сервер.",
		"heading": "API Validator",
		"subtitle": "API Validator помогает проверять JSON-payload запросов на соответствие JSON Schema прямо в браузере. Быстро выявляйте несоответствия схеме, некорректные типы данных и отсутствующие обязательные поля при разработке API и QA-тестировании.",
		"payloadLabel": "Payload JSON",
		"outputLabel": "Output",
		"schemaLabel": "Schema JSON",
		"validate": "Валидировать",
		"autoValidate": "Авто-валидация",
		"formatPayload": "Форматировать Payload",
		"formatSchema": "Форматировать Schema",
		"selectPreset": "Sample Schema",
		"reset": "Сбросить",
		"valid": "Валидный",
		"invalid": "Невалидный",
		"parseError": "Ошибка парсинга",
		"schemaParseError": "Ошибка парсинга Schema",
		"line": "Строка",
		"column": "Колонка",
		"error": "ошибка",
		"errors": "ошибок",
		"keyword": "Ключевое слово",
		"expected": "Ожидалось",
		"received": "Получено",
		"copy": "Копировать",
		"copied": "Скопировано!",
		"copyError": "Копировать ошибку",
		"noValidation": "Нажмите Валидировать для проверки JSON по схеме",
		"formattedOutput": "Отформатированный вывод",
		"whatIs": "Что такое API Validator?",
		"parameters": "Параметры",
		"payloadDesc": "JSON payload для валидации",
		"schemaDesc": "JSON Schema (draft 2020-12 или draft-07)",
		"autoValidateDesc": "Автоматически валидировать при изменении ввода",
		"presets": "Presets",
		"presetsDesc": "Готовые схемы и payload'ы для типовых API-запросов",
		"format": "Форматирование",
		"formatDesc": "Форматировать JSON с правильными отступами",
		"privacy": "Приватность",
		"privacyText": "Вся валидация происходит локально в браузере. Данные не отправляются на сервер.",
		"useCases": "Сценарии использования",
		"useCasesSubtitle": "Используйте API Validator для:",
		"useCase1": "проверки JSON запросов перед отправкой",
		"useCase2": "тестирования серверной валидации",
		"useCase3": "поиска ошибок в схеме или payload-e",
		"useCase4": "проверки обязательных полей, типов и форматов данных",
		"whyUse": "Зачем использовать этот инструмент?",
		"whyUse1": "Мгновенная проверка API payload-ов",
		"whyUse2": "Поддержка JSON Schema (draft-07, draft-2020-12)",
		"whyUse3": "Подходит для разработчиков и QA инженеров",
		"typicalWorkflow": "Типовой сценарий работы",
		"workflow1": "Вставьте или введите JSON payload",
		"workflow2": "Добавьте или выберите JSON Schema",
		"workflow3": "Нажмите Validate или включите авто-валидацию",
		"workflow4": "Просмотрите ошибки или статус валидности",
		"workflow5": "При необходимости скопируйте отформатированный результат"
	},
	"statusCodeReference": {
		"title": "HTTP Status Codes Explorer - QA Toolbox",
		"description": "Быстрый локальный справочник HTTP статус-кодов с описанием, примерами использования и шаблонами API ответов.",
		"heading": "HTTP Status Codes Explorer",
		"subtitle": "Быстрый справочник HTTP статус-кодов с описанием, примерами использования и рекомендуемыми API ответами.",
		"searchPlaceholder": "Поиск по коду или ключевому слову...",
		"categoryAll": "Все",
		"category1xx": "1xx",
		"category2xx": "2xx",
		"category3xx": "3xx",
		"category4xx": "4xx",
		"category5xx": "5xx",
		"commonOnly": "Только распространенные",
		"categoryLabel": {
			"informational": "Информационные",
			"success": "Успех",
			"redirection": "Перенаправление",
			"clientError": "Ошибка клиента",
			"serverError": "Ошибка сервера"
		},
		"whenToUse": "Когда использовать",
		"commonCauses": "Типичные причины",
		"whatToReturn": "Что возвращать",
		"testingChecklist": "Чек-лист для тестирования",
		"relatedCodes": "Связанные коды",
		"copyJson": "Копировать JSON",
		"copyTitle": "Копировать заголовок",
		"copied": "Скопировано!",
		"noResults": "Ничего не найдено",
		"noResultsSuggestion": "Попробуйте поиск: 404, not found, rate limit, unauthorized",
		"whatIs": "Что такое HTTP Status Codes Explorer?",
		"whatIsDescription": "HTTP Status Codes Explorer — это локальный инструмент для быстрого понимания HTTP статус-кодов, их типичных причин и рекомендуемых API ответов. Помогает QA инженерам, разработчикам и бэкенд инженерам принимать обоснованные решения относительно выбора статус-кодов и структуры ответов об ошибках.",
		"qaUsage": "Как QA использует статус-коды в тестировании API",
		"qaUsageDescription": "QA инженеры используют статус-коды для проверки поведения API, тестирования обработки ошибок и обеспечения правильных форматов ответов. Этот инструмент помогает определить правильный статус-код для различных сценариев и предоставляет примеры ответов для тестирования.",
		"commonMistakes": "Типичные ошибки: 401 vs 403, 409 vs 422, 502 vs 504",
		"commonMistakesDescription": "401 (Unauthorized) означает, что аутентификация отсутствует или невалидна, тогда как 403 (Forbidden) означает, что пользователь аутентифицирован, но не имеет разрешения. 409 (Conflict) указывает на конфликт состояния, тогда как 422 (Unprocessable Entity) означает, что запрос правильно сформирован, но семантически невалиден. 502 (Bad Gateway) — это ошибка upstream сервера, тогда как 504 (Gateway Timeout) означает, что upstream сервер не ответил вовремя.",
		"statusCodes": {
			"100": {
				"summary": "Продолжить. Сервер получил заголовки запроса, и клиент должен продолжить отправку тела запроса.",
				"whenToUse1": "Заголовок Expect указывает, что клиент отправит тело",
				"whenToUse2": "Большая загрузка тела запроса",
				"causes1": "Клиент отправил заголовок Expect: 100-continue",
				"causes2": "Сервер готов получить тело запроса",
				"checklist1": "Проверьте, что клиент обрабатывает ответ 100",
				"checklist2": "Проверьте, что тело запроса отправляется после 100"
			},
			"101": {
				"summary": "Переключение протоколов. Сервер переключает протоколы по запросу клиента.",
				"whenToUse1": "Обновление до WebSocket",
				"whenToUse2": "Запрос на обновление протокола",
				"causes1": "Клиент запросил обновление протокола",
				"checklist1": "Проверьте, что обновление протокола успешно"
			},
			"200": {
				"summary": "Запрос успешен. Стандартный ответ для успешных HTTP запросов.",
				"whenToUse1": "Успешные GET, PUT или PATCH запросы",
				"whenToUse2": "Возврат данных в теле ответа",
				"whenToUse3": "Стандартный успешный ответ",
				"causes1": "Нормальная успешная обработка запроса",
				"causes2": "Ресурс успешно получен или обновлен",
				"checklist1": "Проверьте, что тело ответа содержит ожидаемые данные",
				"checklist2": "Проверьте, что заголовок Content-Type соответствует формату ответа",
				"checklist3": "Убедитесь, что ответ правильно отформатирован"
			},
			"201": {
				"summary": "Ресурс успешно создан. Обычно используется после POST запросов, которые создают новые ресурсы.",
				"whenToUse1": "После успешного POST запроса, создающего новый ресурс",
				"whenToUse2": "Когда возвращается созданный ресурс в теле ответа",
				"causes1": "Новый ресурс успешно создан",
				"causes2": "Создание ресурса с заголовком Location",
				"checklist1": "Проверьте, что заголовок Location указывает на новый ресурс",
				"checklist2": "Проверьте, что тело ответа содержит созданный ресурс",
				"checklist3": "Убедитесь, что ID ресурса включен"
			},
			"204": {
				"summary": "Запрос успешен, но нет содержимого для возврата. Используется для успешных операций, которые не требуют тела ответа.",
				"whenToUse1": "Успешные DELETE запросы",
				"whenToUse2": "Успешные PUT/PATCH без необходимости ответа",
				"causes1": "Операция успешно завершена без содержимого",
				"checklist1": "Проверьте, что тело ответа пустое",
				"checklist2": "Проверьте, что операция действительно успешна"
			},
			"202": {
				"summary": "Принято. Запрос принят для обработки, но обработка еще не завершена.",
				"whenToUse1": "Асинхронная обработка запроса",
				"whenToUse2": "Запрос поставлен в очередь для фоновой обработки",
				"causes1": "Запрос принят, но еще не обработан",
				"checklist1": "Проверьте, что запрос действительно обрабатывается",
				"checklist2": "Проверьте, предоставлена ли конечная точка статуса"
			},
			"301": {
				"summary": "Перемещено навсегда. Ресурс был постоянно перемещен на новый адрес.",
				"whenToUse1": "Ресурс постоянно перемещен на новый URL",
				"whenToUse2": "Структура URL изменена навсегда",
				"causes1": "Местоположение ресурса изменено",
				"causes2": "Реструктуризация домена или пути",
				"checklist1": "Проверьте, что заголовок Location указывает на новый URL",
				"checklist2": "Проверьте, что перенаправление постоянное"
			},
			"302": {
				"summary": "Найдено (временное перенаправление). Ресурс временно расположен по другому адресу.",
				"whenToUse1": "Временное перемещение ресурса",
				"whenToUse2": "Временное изменение URL",
				"causes1": "Ресурс временно перемещен",
				"causes2": "Обслуживание или балансировка нагрузки",
				"checklist1": "Проверьте, что заголовок Location присутствует",
				"checklist2": "Проверьте метод перенаправления (GET vs POST)"
			},
			"304": {
				"summary": "Не изменено. Ресурс не изменялся с момента последнего запроса.",
				"whenToUse1": "Условный GET с If-None-Match или If-Modified-Since",
				"whenToUse2": "Кэшированный ресурс все еще валиден",
				"causes1": "Ресурс не изменялся с момента последнего запроса",
				"checklist1": "Проверьте заголовки ETag или Last-Modified",
				"checklist2": "Проверьте, что тело ответа пустое"
			},
			"307": {
				"summary": "Временное перенаправление. Запрос должен быть повторен с тем же HTTP методом.",
				"whenToUse1": "Временное перенаправление с сохранением метода",
				"whenToUse2": "Балансировка нагрузки или обслуживание",
				"causes1": "Временное перемещение сервера",
				"checklist1": "Проверьте, что HTTP метод сохранен",
				"checklist2": "Проверьте заголовок Location"
			},
			"308": {
				"summary": "Постоянное перенаправление. Запрос и все будущие запросы должны быть повторены с использованием предоставленного URI.",
				"whenToUse1": "Постоянное перенаправление с сохранением метода",
				"whenToUse2": "Постоянное изменение URL",
				"causes1": "Постоянное перемещение ресурса",
				"checklist1": "Проверьте, что метод и тело сохранены",
				"checklist2": "Проверьте, что перенаправление действительно постоянное"
			},
			"400": {
				"summary": "Неверный синтаксис запроса или параметры. Сервер не может обработать запрос из-за ошибки клиента.",
				"whenToUse1": "Неверный синтаксис запроса",
				"whenToUse2": "Неверные параметры запроса",
				"whenToUse3": "Отсутствуют обязательные поля",
				"causes1": "Неверный синтаксис JSON",
				"causes2": "Отсутствуют обязательные параметры",
				"causes3": "Неверные типы параметров",
				"causes4": "Неверно сформированное тело запроса",
				"checklist1": "Проверьте, что сообщение об ошибке объясняет проблему",
				"checklist2": "Проверьте, что ответ об ошибке включает requestId",
				"checklist3": "Убедитесь, что формат ошибки согласован",
				"checklist4": "Тестируйте с различными невалидными входами"
			},
			"401": {
				"summary": "Требуется аутентификация или она не удалась. Клиент должен аутентифицироваться для получения запрашиваемого ответа.",
				"whenToUse1": "Отсутствует или невалиден токен аутентификации",
				"whenToUse2": "Срок действия учетных данных аутентификации истек",
				"whenToUse3": "Схема аутентификации не поддерживается",
				"causes1": "Заголовок Authorization не предоставлен",
				"causes2": "Невалидный или устаревший токен",
				"causes3": "Учетные данные аутентификации неверны",
				"checklist1": "Проверьте, что заголовок WWW-Authenticate присутствует",
				"checklist2": "Проверьте, что сообщение об ошибке не раскрывает чувствительную информацию",
				"checklist3": "Тестируйте с отсутствующими, невалидными и устаревшими токенами",
				"checklist4": "Убедитесь, что используется 401, а не 403 для проблем с аутентификацией"
			},
			"403": {
				"summary": "Доступ запрещен. Клиент не имеет разрешения на доступ к ресурсу.",
				"whenToUse1": "Пользователь аутентифицирован, но не имеет разрешения",
				"whenToUse2": "Ресурс существует, но доступ запрещен",
				"whenToUse3": "Недостаточно привилегий для операции",
				"causes1": "Пользователь не имеет необходимых разрешений",
				"causes2": "Доступ к ресурсу ограничен политикой",
				"causes3": "Операция не разрешена для роли пользователя",
				"checklist1": "Проверьте, что пользователь аутентифицирован (не 401)",
				"checklist2": "Проверьте, что сообщение об ошибке объясняет проблему с разрешениями",
				"checklist3": "Тестируйте с различными ролями пользователей"
			},
			"404": {
				"summary": "Ресурс не найден. Сервер не может найти запрашиваемый ресурс.",
				"whenToUse1": "Ресурс не существует",
				"whenToUse2": "Неверный ID ресурса или путь",
				"whenToUse3": "Конечная точка не существует",
				"causes1": "Ресурс был удален",
				"causes2": "Неверный URL или ID ресурса",
				"causes3": "Ресурс никогда не существовал",
				"causes4": "Ошибка в пути запроса",
				"checklist1": "Проверьте, что сообщение об ошибке понятно",
				"checklist2": "Проверьте, что ответ не раскрывает внутреннюю структуру",
				"checklist3": "Тестируйте с различными невалидными ID"
			},
			"405": {
				"summary": "Метод не разрешен. HTTP метод не разрешен для запрашиваемого ресурса.",
				"whenToUse1": "HTTP метод не поддерживается для конечной точки",
				"whenToUse2": "Конечная точка существует, но метод неверен",
				"causes1": "Метод не реализован для ресурса",
				"causes2": "Разрешены только определенные методы",
				"checklist1": "Проверьте, что заголовок Allow перечисляет разрешенные методы",
				"checklist2": "Тестируйте с различными HTTP методами"
			},
			"408": {
				"summary": "Тайм-аут запроса. Сервер не дождался запроса.",
				"whenToUse1": "Клиент слишком долго отправлял запрос",
				"whenToUse2": "Тайм-аут запроса до завершения",
				"causes1": "Клиент не отправил запрос вовремя",
				"causes2": "Тайм-аут сетевого соединения",
				"checklist1": "Проверьте конфигурацию тайм-аута",
				"checklist2": "Тестируйте с медленными соединениями"
			},
			"409": {
				"summary": "Конфликт ресурса. Запрос конфликтует с текущим состоянием ресурса.",
				"whenToUse1": "Дублирование создания ресурса",
				"whenToUse2": "Конфликт одновременного изменения",
				"whenToUse3": "Конфликт состояния (например, удаление активного ресурса)",
				"causes1": "Ресурс уже существует с таким же идентификатором",
				"causes2": "Конфликт оптимистичной блокировки",
				"causes3": "Нарушение бизнес-правил",
				"checklist1": "Проверьте, что ошибка объясняет конфликт",
				"checklist2": "Проверьте, нужна ли логика повторной попытки",
				"checklist3": "Тестируйте сценарии одновременного изменения"
			},
			"410": {
				"summary": "Удалено. Ресурс больше недоступен и не будет доступен снова.",
				"whenToUse1": "Ресурс постоянно удален",
				"whenToUse2": "Ресурс удален и не вернется",
				"causes1": "Ресурс постоянно удален",
				"causes2": "Ресурс устарел и удален",
				"checklist1": "Проверьте, что ресурс не будет восстановлен",
				"checklist2": "Проверьте, что сообщение об ошибке объясняет удаление"
			},
			"412": {
				"summary": "Условие не выполнено. Одно или более условий в полях заголовков запроса оценено как ложные.",
				"whenToUse1": "Условие If-Match или If-None-Match не выполнено",
				"whenToUse2": "Условие If-Unmodified-Since не выполнено",
				"causes1": "Несоответствие ETag",
				"causes2": "Ресурс изменен с момента последнего запроса",
				"checklist1": "Проверьте заголовки условий",
				"checklist2": "Тестируйте сценарии оптимистичной блокировки"
			},
			"413": {
				"summary": "Тело запроса слишком большое. Сущность запроса больше лимитов, определенных сервером.",
				"whenToUse1": "Тело запроса превышает лимит размера",
				"whenToUse2": "Файл для загрузки слишком большой",
				"causes1": "Тело запроса превышает лимит сервера",
				"causes2": "Размер файла слишком большой",
				"checklist1": "Проверьте, что лимит размера задокументирован",
				"checklist2": "Тестируйте с различными размерами тела запроса"
			},
			"415": {
				"summary": "Неподдерживаемый тип медиа. Сущность запроса имеет тип медиа, который сервер не поддерживает.",
				"whenToUse1": "Неверный заголовок Content-Type",
				"whenToUse2": "Сервер принимает только определенные типы медиа",
				"causes1": "Content-Type не поддерживается (например, XML вместо JSON)",
				"causes2": "Отсутствует или неверный заголовок Content-Type",
				"checklist1": "Проверьте, что заголовок Accept проверяется",
				"checklist2": "Тестируйте с различными значениями Content-Type"
			},
			"422": {
				"summary": "Необрабатываемая сущность. Запрос правильно сформирован, но семантически невалиден.",
				"whenToUse1": "Ошибки валидации в теле запроса",
				"whenToUse2": "Валидация бизнес-логики не удалась",
				"whenToUse3": "Семантические ошибки (например, невалидный диапазон дат)",
				"causes1": "Валидация поля не удалась",
				"causes2": "Нарушение бизнес-правил",
				"causes3": "Неверные связи данных",
				"checklist1": "Проверьте, что детали ошибки указывают конкретные поля",
				"checklist2": "Проверьте, что формат ошибки включает ошибки на уровне полей",
				"checklist3": "Тестируйте с различными сценариями валидации",
				"checklist4": "Убедитесь, что используется 422, а не 400 для валидации"
			},
			"429": {
				"summary": "Слишком много запросов. Пользователь отправил слишком много запросов за определенное время.",
				"whenToUse1": "Превышен лимит скорости",
				"whenToUse2": "Слишком много запросов с того же IP/пользователя",
				"causes1": "Превышен порог лимита скорости",
				"causes2": "Слишком частые вызовы API",
				"causes3": "Сработала защита от DDoS",
				"checklist1": "Проверьте, что заголовок Retry-After присутствует",
				"checklist2": "Проверьте, что сообщение об ошибке включает информацию о лимите скорости",
				"checklist3": "Тестируйте поведение ограничения скорости"
			},
			"500": {
				"summary": "Внутренняя ошибка сервера. Сервер столкнулся с неожиданным условием.",
				"whenToUse1": "Неожиданная ошибка сервера",
				"whenToUse2": "Необработанное исключение",
				"causes1": "Ошибка кода приложения",
				"causes2": "Сбой подключения к базе данных",
				"causes3": "Сбой стороннего сервиса",
				"causes4": "Ошибка конфигурации",
				"checklist1": "Проверьте, что ошибка не раскрывает чувствительную информацию",
				"checklist2": "Проверьте, что requestId включен для отладки",
				"checklist3": "Убедитесь в правильном логировании ошибок"
			},
			"501": {
				"summary": "Не реализовано. Сервер не поддерживает функциональность, необходимую для выполнения запроса.",
				"whenToUse1": "Функция еще не реализована",
				"whenToUse2": "Метод не поддерживается сервером",
				"causes1": "Конечная точка или функция недоступна",
				"checklist1": "Проверьте, что функция действительно не реализована",
				"checklist2": "Проверьте, не более ли уместен 404"
			},
			"502": {
				"summary": "Плохой шлюз. Сервер, действующий как шлюз, получил невалидный ответ.",
				"whenToUse1": "Невалидный ответ от upstream сервера",
				"whenToUse2": "Ошибка upstream сервера",
				"causes1": "Upstream сервер вернул невалидный ответ",
				"causes2": "Проблема конфигурации прокси/шлюза",
				"causes3": "Сетевая проблема между серверами",
				"checklist1": "Проверьте, что сообщение об ошибке понятно",
				"checklist2": "Проверьте, уместна ли повторная попытка",
				"checklist3": "Тестируйте сбои upstream сервера"
			},
			"503": {
				"summary": "Сервис недоступен. Сервер временно не может обработать запрос.",
				"whenToUse1": "Сервис временно недоступен для обслуживания",
				"whenToUse2": "Сервер перегружен",
				"whenToUse3": "Временная недоступность",
				"causes1": "Запланированное обслуживание",
				"causes2": "Перегрузка сервера",
				"causes3": "Зависимый сервис недоступен",
				"checklist1": "Проверьте заголовок Retry-After, если применимо",
				"checklist2": "Проверьте, что сообщение об ошибке объясняет недоступность",
				"checklist3": "Тестируйте сценарии восстановления сервиса"
			},
			"504": {
				"summary": "Тайм-аут шлюза. Сервер, действующий как шлюз, не получил своевременный ответ.",
				"whenToUse1": "Тайм-аут upstream сервера",
				"whenToUse2": "Запрос занял слишком много времени для обработки",
				"causes1": "Upstream сервер не ответил вовремя",
				"causes2": "Сетевой тайм-аут",
				"causes3": "Медленная обработка upstream",
				"checklist1": "Проверьте конфигурацию тайм-аута",
				"checklist2": "Проверьте, можно ли оптимизировать запрос",
				"checklist3": "Тестируйте сценарии тайм-аута"
			}
		}
	},
	"userAgentParser": {
		"title": "Парсер User-Agent - QA Toolbox",
		"description": "Распарсите строки User-Agent для извлечения информации о браузере, ОС, устройстве и версии локально."
	},
	"headersInspector": {
		"title": "Инспектор заголовков - QA Toolbox",
		"description": "Парсинг и анализ HTTP заголовков. Поймите назначение каждого заголовка, обнаружьте типичные проблемы и получите быстрые действия копирования.",
		"heading": "Инспектор заголовков",
		"subtitle": "Парсинг HTTP заголовков, понимание их назначения и обнаружение типичных проблем конфигурации.",
		"inputLabel": "Заголовки",
		"placeholder": "Вставьте заголовки из DevTools или вывода curl...\n\nПример:\nContent-Type: application/json\nAuthorization: Bearer token123",
		"typeLabel": "Тип:",
		"typeRequest": "Запрос",
		"typeResponse": "Ответ",
		"autoParse": "Авто-парсинг",
		"parse": "Парсить",
		"reset": "Сбросить",
		"example": "Пример",
		"exampleRequest": "Заголовки запроса",
		"exampleResponse": "Заголовки ответа",
		"exampleCors": "Пример ошибки CORS",
		"exampleCookie": "Пример проблемы с cookie",
		"headersList": "Заголовки",
		"noHeaders": "Вставьте заголовки выше и нажмите Парсить, чтобы начать.",
		"details": {
			"whatItDoes": "Что делает",
			"whenToUse": "Когда использовать",
			"commonMistakes": "Типичные ошибки",
			"securityNotes": "Примечания безопасности",
			"quickActions": "Быстрые действия",
			"copyName": "Копировать название",
			"copyValue": "Копировать значение",
			"copyFull": "Копировать заголовок:значение",
			"selectHeader": "Выберите заголовок для просмотра деталей",
			"noInfo": "Информация для этого заголовка недоступна.",
			"duplicates": "дубликатов",
			"recommendation": "Рекомендация:",
			"hints": {
				"cacheValidationMissing": "Рекомендуется добавить ETag или Last-Modified для валидации кеша.",
				"sameSiteNoneSecure": "Добавьте флаг Secure при использовании SameSite=None.",
				"cannotUseStarWithCredentials": "Нельзя использовать \"*\" с credentials. Используйте конкретный origin вместо этого.",
				"requiresSpecificAcao": "Требуется конкретный Access-Control-Allow-Origin (не \"*\")."
			}
		},
		"issues": {
			"detectedIssues": "Обнаруженные проблемы",
			"showDetectedIssues": "Показать обнаруженные проблемы",
			"errors": "ошибок",
			"warnings": "предупреждений",
			"info": "инфо",
			"showOnlyErrors": "Показать только ошибки",
			"hideIssues": "Скрыть проблемы",
			"less": "Меньше",
			"more": "Больше",
			"corsStarWithCredentials": "Неверная CORS: ACAO=\"*\" с ACAC=\"true\"",
			"corsStarWithCredentialsWhy": "Спецификация CORS не позволяет wildcard origin с credentials. Используйте конкретный origin.",
			"corsVaryOrigin": "Рекомендуется Vary: Origin при использовании конкретного ACAO с credentials",
			"corsVaryOriginWhy": "При использовании конкретного origin с credentials, добавьте Vary: Origin для правильного кеширования.",
			"corsMissingAcao": "Обнаружен CORS запрос, но нет заголовка ACAO в ответе",
			"corsMissingAcaoWhy": "Запрос содержит заголовок Origin, но ответ не указывает разрешённые origins.",
			"cacheNoStoreWithEtag": "Cache-Control: no-store с ETag может быть избыточным",
			"cacheNoStoreWithEtagWhy": "no-store предотвращает кеширование, поэтому валидация ETag не нужна.",
			"cacheMissingForApi": "Ответ API (JSON) без заголовка Cache-Control",
			"cacheMissingForApiWhy": "Ответы API должны явно указывать поведение кеширования.",
			"securityMissingHsts": "Обнаружен HTTPS, но отсутствует заголовок HSTS",
			"securityMissingHstsWhy": "HSTS помогает предотвратить атаки снижения протокола.",
			"securityMissingXContentType": "HTML контент без заголовка X-Content-Type-Options",
			"securityMissingXContentTypeWhy": "Предотвращает атаки MIME type sniffing.",
			"cookieSameSiteNoneNoSecure": "Set-Cookie: SameSite=None требует флаг Secure",
			"cookieSameSiteNoneNoSecureWhy": "Cookie с SameSite=None должны быть помечены Secure для предотвращения перехвата.",
			"cookieMissingHttpOnly": "Cookie типа сессии без флага HttpOnly",
			"cookieMissingHttpOnlyWhy": "HttpOnly предотвращает доступ JavaScript, уменьшая поверхность атаки XSS."
		},
		"headers": {
			"authorization": {
				"description": "Содержит учётные данные для аутентификации клиента на сервере.",
				"whenToUse1": "Bearer токены для аутентификации API",
				"whenToUse2": "Учётные данные Basic аутентификации",
				"mistakes1": "Отправка токенов в параметрах запроса вместо заголовка",
				"mistakes2": "Не использование HTTPS для чувствительных учётных данных",
				"security": "Всегда используйте HTTPS при отправке учётных данных. Рассмотрите срок действия и ротацию токенов."
			},
			"wwwAuthenticate": {
				"description": "Указывает схему аутентификации, необходимую для доступа.",
				"whenToUse1": "Ответы 401 Unauthorized для указания необходимой аутентификации",
				"mistakes1": "Отсутствие на ответах 401"
			},
			"contentType": {
				"description": "Указывает медиа-тип ресурса.",
				"whenToUse1": "Тип контента тела запроса (POST, PUT, PATCH)",
				"whenToUse2": "Тип контента тела ответа",
				"mistakes1": "Отсутствие charset для текстовых типов",
				"mistakes2": "Неверный MIME тип (например, application/json vs text/json)"
			},
			"accept": {
				"description": "Указывает медиа-типы, приемлемые для ответа.",
				"whenToUse1": "Клиент указывает желаемый формат ответа",
				"mistakes1": "Не указывают заголовок Accept, когда формат важен"
			},
			"acceptEncoding": {
				"description": "Указывает поддерживаемые методы сжатия.",
				"whenToUse1": "Для оптимизации размера ответа.",
				"mistakes1": "Отсутствие сжатия",
				"mistakes2": "Игнорирование заголовка сервером",
				"security": "Сжатие может влиять на безопасность."
			},
			"acceptLanguage": {
				"description": "Определяет предпочтительные языки клиента.",
				"whenToUse1": "Для локализации ответов.",
				"mistakes1": "Отсутствие fallback-языка",
				"mistakes2": "Игнорирование заголовка сервером",
				"security": "Может использоваться для fingerprinting."
			},
			"contentEncoding": {
				"description": "Указывает преобразования кодирования, применённые к телу сообщения.",
				"whenToUse1": "Сжатые ответы (gzip, br, deflate)",
				"mistakes1": "Несоответствие Content-Encoding с фактическим кодированием"
			},
			"contentLength": {
				"description": "Размер тела сообщения в байтах.",
				"whenToUse1": "Указание размера тела запроса/ответа",
				"mistakes1": "Неверная длина, вызывающая проблемы соединения"
			},
			"cacheControl": {
				"description": "Директивы для механизмов кеширования в запросах и ответах.",
				"whenToUse1": "Контроль поведения кеширования (public, private, no-cache, max-age)",
				"whenToUse2": "Ответы API, которые не должны кешироваться",
				"mistakes1": "Кеширование чувствительных данных",
				"mistakes2": "Отсутствие Cache-Control на ответах API"
			},
			"etag": {
				"description": "Тег сущности для валидации кеша.",
				"whenToUse1": "Условные запросы и валидация кеша",
				"mistakes1": "Слабые ETag, когда нужны сильные"
			},
			"lastModified": {
				"description": "Указывает дату последнего изменения ресурса.",
				"whenToUse1": "Для кеширования и условных запросов.",
				"mistakes1": "Отсутствует для статических ресурсов",
				"mistakes2": "Некорректный формат даты",
				"security": "Может раскрывать информацию об обновлениях ресурса."
			},
			"ifNoneMatch": {
				"description": "Условный запрос с использованием ETag для валидации кеша.",
				"whenToUse1": "Проверка, изменился ли ресурс с последнего запроса",
				"mistakes1": "Не обработка ответов 304 Not Modified"
			},
			"expires": {
				"description": "Дата/время, после которого ответ считается устаревшим.",
				"whenToUse1": "Устаревшее окончание кеша (лучше использовать Cache-Control)",
				"mistakes1": "Использование Expires вместо Cache-Control"
			},
			"vary": {
				"description": "Заголовки, влияющие на выбор ответа.",
				"whenToUse1": "CORS ответы с credentials и конкретным origin",
				"mistakes1": "Отсутствие Vary: Origin, когда нужно"
			},
			"origin": {
				"description": "Origin запроса (схема, хост, порт).",
				"whenToUse1": "CORS запросы из браузеров"
			},
			"accessControlAllowOrigin": {
				"description": "Указывает разрешённые origins для CORS запросов.",
				"whenToUse1": "CORS-включённые ответы API",
				"mistakes1": "Использование * с credentials (не разрешено)",
				"mistakes2": "Не валидация origin на стороне сервера"
			},
			"accessControlAllowCredentials": {
				"description": "Указывает, могут ли быть включены credentials в CORS запросы.",
				"whenToUse1": "CORS запросы, которые требуют cookies или auth заголовков",
				"mistakes1": "Установка true с ACAO=\"*\" (невалидно)"
			},
			"accessControlAllowHeaders": {
				"description": "Заголовки, разрешённые в CORS запросах.",
				"whenToUse1": "CORS preflight ответы"
			},
			"accessControlAllowMethods": {
				"description": "HTTP методы, разрешённые в CORS запросах.",
				"whenToUse1": "CORS preflight ответы"
			},
			"accessControlExposeHeaders": {
				"description": "Заголовки, доступные JavaScript в CORS ответах.",
				"whenToUse1": "CORS ответы, экспортирующие кастомные заголовки"
			},
			"setCookie": {
				"description": "Устанавливает cookie в браузере.",
				"whenToUse1": "Управление сессиями, настройки, отслеживание",
				"mistakes1": "SameSite=None без Secure",
				"mistakes2": "Отсутствие HttpOnly для сессионных cookie",
				"mistakes3": "Не установка соответствующего срока действия",
				"security": "Используйте HttpOnly для сессионных cookie, Secure для HTTPS-only, и соответствующие значения SameSite."
			},
			"cookie": {
				"description": "Содержит сохранённые cookie для домена.",
				"whenToUse1": "Отправка cookie с запросами"
			},
			"contentSecurityPolicy": {
				"description": "Контролирует ресурсы, которые браузер может загрузить для предотвращения XSS.",
				"whenToUse1": "Веб-страницы, которые требуют защиты от XSS",
				"mistakes1": "Слишком ограниченная политика, ломающая функциональность",
				"security": "Начните с default-src 'self' и постепенно добавляйте нужные источники."
			},
			"strictTransportSecurity": {
				"description": "Принуждает HTTPS соединения для домена.",
				"whenToUse1": "Сайты только с HTTPS",
				"mistakes1": "Включение поддоменов, когда не готовы",
				"security": "Используйте max-age минимум 31536000 (1 год) и includeSubDomains, когда уместно."
			},
			"xFrameOptions": {
				"description": "Предотвращает атаки clickjacking путём контроля фреймования.",
				"whenToUse1": "Страницы, которые не должны быть встроены в iframe",
				"mistakes1": "Использование DENY, когда достаточно SAMEORIGIN"
			},
			"xContentTypeOptions": {
				"description": "Предотвращает атаки MIME type sniffing.",
				"whenToUse1": "Все HTML ответы",
				"mistakes1": "Отсутствие на HTML контенте"
			},
			"referrerPolicy": {
				"description": "Контролирует информацию referrer, отправляемую с запросами.",
				"whenToUse1": "Приложения, чувствительные к конфиденциальности"
			},
			"permissionsPolicy": {
				"description": "Контролирует функции браузера и API, доступные для страницы.",
				"whenToUse1": "Ограничение доступа к функциям браузера"
			},
			"location": {
				"description": "URL для ответов перенаправления.",
				"whenToUse1": "3xx ответы перенаправления",
				"mistakes1": "Относительные URL, когда нужны абсолютные"
			},
			"retryAfter": {
				"description": "Время ожидания перед повторным запросом.",
				"whenToUse1": "429 Too Many Requests или 503 Service Unavailable"
			},
			"xForwardedFor": {
				"description": "Оригинальный IP адрес клиента за прокси.",
				"whenToUse1": "Проксированные запросы",
				"mistakes1": "Доверие без валидации (риск безопасности)"
			},
			"xForwardedProto": {
				"description": "Оригинальный протокол (http/https) за прокси.",
				"whenToUse1": "Проксированные запросы"
			},
			"forwarded": {
				"description": "Стандартизированная информация о прокси (заменяет X-Forwarded-*).",
				"whenToUse1": "Проксированные запросы (лучше чем X-Forwarded-*)"
			},
			"serverTiming": {
				"description": "Метрики производительности с сервера.",
				"whenToUse1": "Мониторинг и отладка производительности"
			},
			"pragma": {
				"description": "Устаревший механизм управления кешированием (HTTP/1.0). Чаще всего используется как no-cache.",
				"whenToUse1": "Для совместимости со старыми прокси и клиентами, обычно вместе с Cache-Control.",
				"mistakes1": "Полагаться только на Pragma вместо Cache-Control. Современные браузеры ориентируются именно на Cache-Control."
			},
			"date": {
				"description": "Время формирования ответа на сервере (GMT).",
				"whenToUse1": "Для отладки кеширования, анализа логов, работы CDN и проверки синхронизации времени.",
				"mistakes1": "Неверное серверное время приводит к проблемам с TTL, кешем и механизмами подписи (JWT, signed URLs)."
			},
			"server": {
				"description": "Информация о сервере или прокси, который обработал запрос (например envoy, nginx, cloudflare).",
				"whenToUse1": "Для диагностики инфраструктуры и понимания, кто реально отвечает на запрос — приложение или прокси.",
				"mistakes1": "Избыточная детализация может помогать атакующим. В production часто скрывают или минимизируют этот заголовок.",
				"security": "Рекомендуется скрывать или обобщать заголовок Server для снижения утечки информации."
			},
			"xEnvoyUpstreamServiceTime": {
				"description": "Показывает, сколько времени upstream-сервис (бекенд) обрабатывал запрос внутри Envoy (в миллисекундах).",
				"whenToUse1": "Для анализа производительности и отделения задержек бекенда от сетевых и прокси-задержек.",
				"mistakes1": "Путать с общим временем ответа в браузере — этот заголовок не включает сетевые задержки и клиентскую обработку."
			},
			"xXssProtection": {
				"description": "Устаревший механизм XSS-защиты в некоторых браузерах.",
				"whenToUse1": "Практически не рекомендуется. Современные браузеры игнорируют или не поддерживают этот заголовок.",
				"mistakes1": "Считать, что он реально защищает от XSS. Реальная защита — это CSP, корректный escaping и безопасный рендеринг.",
				"security": "Часто устанавливают X-XSS-Protection: 0, чтобы отключить проблемные старые фильтры."
			},
			"referer": {
				"description": "Передаёт URL страницы-источника запроса.",
				"whenToUse1": "Для аналитики и логирования.",
				"mistakes1": "Использование как механизма безопасности",
				"mistakes2": "Ожидание заголовка при строгой Referrer-Policy",
				"security": "Может раскрывать чувствительные URL."
			},
			"userAgent": {
				"description": "Идентифицирует клиент или браузер.",
				"whenToUse1": "Для отладки и аналитики.",
				"mistakes1": "Бизнес-логика на основе User-Agent",
				"security": "Легко подделывается."
			}
		},
		"whatIs": "Что такое Headers Inspector?",
		"whatIsDescription": "Headers Inspector — локальный инструмент, который превращает HTTP-заголовки запроса или ответа в понятный список с пояснениями и типовыми ошибками. Помогает быстро находить проблемы в CORS, кешировании, Content-Type и cookies при отладке API и QA-тестировании — прямо в браузере.",
		"whatYouCanDo": "Что можно сделать в инструменте",
		"whatYouCanDo1": "Вставить заголовки и мгновенно распарсить их в пары ключ/значение",
		"whatYouCanDo2": "Переключать режим Запрос / Ответ",
		"whatYouCanDo3": "Видеть найденные проблемы (error/warning/info) и рекомендации",
		"whatYouCanDo4": "Открывать каждый заголовок: назначение, когда использовать, типовые ошибки",
		"whatYouCanDo5": "Копировать имя, значение или строку Header: value",
		"privacy": "Приватность",
		"privacyText": "Все данные обрабатываются локально в браузере. Данные не отправляются на сервер."
	},
	"cookieDebugger": {
		"title": "Cookie Debugger - QA Toolbox",
		"description": "Парсинг и отладка cookies локально. Понимание атрибутов cookie, обнаружение проблем и симуляция поведения отправки cookie.",
		"heading": "Cookie Debugger",
		"subtitle": "Парсинг и отладка cookies локально в вашем браузере.",
		"modeSetCookie": "Set-Cookie (Ответ)",
		"modeCookie": "Cookie (Запрос)",
		"inputLabel": "Сырые Cookie заголовки",
		"placeholder": "Set-Cookie: session=abc123; Secure; HttpOnly; SameSite=Lax; Path=/; Max-Age=3600",
		"autoParse": "Авто-парсинг",
		"parse": "Парсить",
		"reset": "Сбросить",
		"example": "Пример",
		"exampleSameSiteNone": "SameSite=None без Secure",
		"exampleCrossSite": "Cross-site cookie заблокирован",
		"exampleValidSession": "Валидный session cookie",
		"exampleDomainMismatch": "Несоответствие домена",
		"exampleMultiple": "Несколько cookies",
		"exampleCookieHeader": "Cookie заголовок",
		"cookiesList": "Cookies",
		"showOnlyIssues": "Только проблемы",
		"noCookies": "Cookies еще не распарсены. Вставьте cookie заголовки выше и нажмите Парсить.",
		"context": {
			"title": "Контекст запроса",
			"siteUrl": "URL сайта",
			"requestUrl": "URL запроса",
			"method": "Метод",
			"isHttps": "HTTPS",
			"isTopLevelNavigation": "Top-level навигация",
			"isIframe": "В iframe",
			"isCrossSite": "Cross-site",
			"yes": "Да",
			"no": "Нет",
			"sameSiteNote": "Определение same-site основано на hostname в MVP."
		},
		"details": {
			"willBeSent": "Cookie будет отправлено",
			"willNotBeSent": "Cookie НЕ будет отправлено",
			"warnings": "Предупреждения",
			"attributes": "Атрибуты",
			"hostOnly": "Host-only",
			"notSet": "Не установлено",
			"quickActions": "Быстрые действия",
			"copyName": "Копировать название",
			"copyValue": "Копировать значение",
			"copyFull": "Копировать полную строку",
			"selectCookie": "Выберите cookie для просмотра деталей"
		},
		"issues": {
			"detectedIssues": "Обнаруженные проблемы",
			"showDetectedIssues": "Показать обнаруженные проблемы",
			"errors": "Ошибки",
			"warnings": "Предупреждения",
			"info": "Инфо",
			"hideIssues": "Скрыть проблемы",
			"showOnlyErrors": "Показать только ошибки",
			"sameSiteNoneNoSecure": "SameSite=None требует флаг Secure для работы в современных браузерах.",
			"domainIsIp": "Атрибут Domain является IP-адресом. Cookies с IP-доменами могут работать некорректно.",
			"domainInvalid": "Формат домена кажется невалидным.",
			"noSameSite": "Атрибут SameSite не установлен. Браузеры могут использовать Lax по умолчанию, но поведение может отличаться.",
			"expired": "Cookie просрочено и будет удалено браузером.",
			"maxAgeZero": "Max-Age равен нулю или отрицательный. Cookie будет удалено немедленно.",
			"missingHttpOnly": "Session-подобный cookie не имеет флага HttpOnly, который помогает предотвратить XSS-атаки.",
			"bothExpiresMaxAge": "Установлены и Expires, и Max-Age. Max-Age имеет приоритет.",
			"noPath": "Path не установлен. По умолчанию используется директория пути запроса.",
			"domainMismatch": "Домен cookie не соответствует URL сайта. Cookie может не быть отправлено."
		},
		"simulation": {
			"willBeSent": "Cookie будет отправлено с этим запросом.",
			"secureNotHttps": "Cookie имеет флаг Secure, но запрос не HTTPS.",
			"expired": "Cookie просрочено.",
			"maxAgeZero": "Max-Age cookie равен нулю или отрицательный.",
			"domainMismatch": "Домен cookie не соответствует URL запроса.",
			"pathMismatch": "Путь cookie не соответствует пути запроса.",
			"sameSiteStrictCrossSite": "SameSite=Strict блокирует cross-site запросы.",
			"sameSiteLaxCrossSite": "SameSite=Lax позволяет только cross-site top-level навигационные GET запросы.",
			"sameSiteNoneNoSecure": "SameSite=None требует флаг Secure.",
			"sameSiteNoneNotHttps": "SameSite=None требует HTTPS."
		},
		"whatIs": "Что такое Cookie Debugger?",
		"whatIsDescription": "Cookie Debugger — это локальный инструмент, который парсит Set-Cookie и Cookie заголовки, объясняет атрибуты cookie (Domain, Path, Secure, HttpOnly, SameSite, Max-Age/Expires), обнаруживает типовые проблемы и симулирует, будет ли cookie отправлено для заданного контекста запроса. Вся обработка выполняется локально в вашем браузере.",
		"commonIssues": "Типовые проблемы с cookies",
		"commonIssuesDescription": "Типовые проблемы с cookies включают: SameSite=None без флага Secure (не будет работать в современных браузерах), несоответствия доменов, просроченные cookies, отсутствие HttpOnly для session cookies и некорректные настройки SameSite для cross-site запросов.",
		"privacy": "Приватность",
		"privacyText": "Весь парсинг и симуляция выполняются локально в вашем браузере. Данные никуда не отправляются."
	},
	"privacy": {
		"title": "Конфиденциальность - QA Toolbox",
		"description": "Политика конфиденциальности для QA Toolbox. Мы не собираем, не храним и не передаём никаких данных."
	}
}
